<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Technologies|Mobile Technologies|Native Development on NVIDIA&#160;Android Devices">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Introduction to Android Development</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../resources/stylesheets/style.css" rel="stylesheet" />
        <style>/*&lt;meta /&gt;*/

.button.previous-topic-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/navigate-previous.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.button.current-topic-index-button
{
	-pie-background: linear-gradient(#ffffff, #ececec);
}

.button.next-topic-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/navigate-next.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.needs-pie
{
	behavior: url('../../../Resources/Scripts/PIE.htc');
}

</style>
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
        <script src="../../../Skins/Default/Scripts/Toolbar.js">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop"><a href="../../../index.html#technologies/mobile/native_android_devprocess.htm">Open topic with navigation</a>
        </p>
        <div class="MCBreadcrumbsBox_style.css_0"><span class="MCBreadcrumbsPrefix">You are here: </span><a class="MCBreadcrumbsLink" href="../technologies_aw.htm">Technologies</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="../mobile_technologies.htm">Mobile Technologies</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="native_android_development.htm">Native Development on NVIDIA&#160;Android Devices</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">Introduction to Android Development</span>
        </div>
        <p style="font-size: 8pt;">To view the latest NVIDIA&#160;AndroidWorks documentation, visit <a href="http://docs.nvidia.com/gameworks/index.html" target="_blank">http://docs.nvidia.com/gameworks/index.html</a>. </p>
        <h1><span class="SystemTitle">Introduction to Android Development</span>
        </h1><a name="kanchor124"></a>
        <div id="pageheader">
            <hr style="height: 1px;" width="100%" size="0" align="center" />
        </div>
        <p>We now describe the basics of developing applications with Eclipse. We begin with a short C++ example that you can build and run in your development machine; then we will port the example to run on the Android device, first using Java, then using Java + native code (C/C++), and finally using only native code.</p>
        <p>After you complete this topic you should be able to:</p>
        <ul>
            <li value="1">Create Eclipse projects for host and Android devices.</li>
            <li value="2">Run and debug C++ projects on your host machine.</li>
            <li value="3">Run and debug Android Java Activities.</li>
            <li value="4">Run and debug Android Java Activities that call native code.</li>
            <li value="5">Run and debug Android Native Activities.</li>
        </ul>
        <h3>C++ project on your development machine</h3>
        <p>We will now create our first C++ example program using Eclipse. The goal of this lesson is to get you familiarized with the Eclipse environment, so we will focus on a simple program that you will run on your desktop computer.</p>
        <ol>
            <li value="1">To develop C/C++ projects, you must first open the C/C++ perspective. The <b>Open Perspective</b> toolbar icon is located on the top-right corner of your Eclipse IDE. Each perspective in Eclipse provides a different set of docking arrangements for viewing the content and semantics of your files and projects. The default is the Java perspective; there is also a Debug perspective, and a C++ perspective. Click on the <b>Open Perspective</b> icon, select <i>Other</i> and pick <b>C/C++</b>. <br /><br /> <img src="images/native_android_eclipse_change_perspective.png" /> <br /><img src="images/native_android_eclipse_open_perspective.png" /></li>
            <li value="2">Once on the C++ perspective, we will create the Fibonacci project. Select <b>File &gt; New &gt; C++ project</b> . Enter the project name, Fibonacci, and select <b>Empty Project</b>.<br /><br /><img src="images/native_android_fibo_create_project.png" /> <br /><br />The toolchain option allows you to select which compiler you will use for this project. This will be platform specific: on Linux select <b>Linux GCC</b>; on Windows either <b>MinGW GCC</b> or <b>Cygwin GCC</b>; on Mac select <b>MacOSX GCC</b>. Finally, click on <b>Finish</b>.</li>
            <li value="3">Next, select the newly created Fibonacci project, and right-click to select <i>New &gt; Header File</i>. Enter Fibonacci.h under <b>Header File:</b> and click <b>Finish</b>. <br /><br /><img src="images/native_android_fibo_new_headerfile.png" /></li>
            <li value="4">Add the declaration for our Fibonacci function, as shown below. Enter the text and save the file.<br /><pre class="prettyprint" xml:space="preserve">#ifndef FIBONACCI_H_<br />#define FIBONACCI_H_
<br />unsigned int Fibonacci( unsigned int n );
<br />#endif /* FIBONACCI_H_ */</pre></li>
            <li value="5">Now it is time to create our main function. Right-click on the project name and select <b>New &gt; Source File</b> . Enter <code>main.cpp</code> in the <b>Source File:</b> entry.<br /><br /><img src="images/native_android_fibo_new_sourcefile.png" /></li>
            <li value="6">Our program entry point will call the Fibonacci function and print the result out to the console.<br /><pre class="prettyprint" xml:space="preserve">#include &lt;iostream&gt;<br />#include "Fibonacci.h"<br /><br />int main( int argc, char * argv[] )<br />{<br />    std::cout &lt;&lt; "Fibonacci(10) = " &lt;&lt; Fibonacci( 10 ) &lt;&lt; std::endl;<br />}</pre></li>
            <li value="7">Now we will write the Fibonacci function. Create a new source file, name it Fibonacci.cpp and enter the text shown below. <br /><pre class="prettyprint" xml:space="preserve">#include "Fibonacci.h"<br />unsigned int Fibonacci( unsigned int n )<br />{<br />    if( n == 1 ) { return 1; }<br />    if( n == 0 ) { return 0; }
<br />    return Fibonacci( n - 1 ) + Fibonacci( n - 2 );<br />}</pre></li>
            <li value="8">The program is done, let's build the executable. Before doing this, close any project in project explorer tab and remember to save any file before building. Then, right-click the project and select <b>Build Project</b>. In the <b>Console</b> tab, you should see the build progressing and succeeding.<br /><br /><img src="images/native_android_fibo_build_console.png" /><br /></li>
            <li value="9">Run the project. On the toolbar you will find two buttons, one for debugging and one for running the program.<br /><br /><img src="images/native_android_eclipse_run_debug.png" /><br /></li>
            <li value="10">Hit the run button (with the white triangle) and watch the <b>Console</b> tab in Eclipse, which will show the results of the compilation and then the output of the execution of the program.<br /><br /><img src="images/native_android_fibo_console.png" /> <br /> <table><col style="width: 35px;" /><col style="width: 660px;" /><tbody><tr><td style="background-color: #ffffe0;vertical-align: middle;text-align: center;"><img src="images/notebox.png" /></td><td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> If you get an error message stating that the binary couldn't be found, go back to the previous step and make sure the project is built correctly.</td></tr></tbody></table></li>
            <li value="11">After the program prints out the result of the Fibonacci call, it will exit.</li>
        </ol>
        <p>We will now debug the program to trace its execution.</p>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> Debugging requires gdb to be in your PATH. On Windows, you will be either using Cygwin gdb or MinGW gdb. If you are using Cygwin as installed by AndroidWorks, gdb will be missing. Run <code>setup.exe</code> under NVPACK/cygwin, select "install from Internet"  and install the gdb package (under Devel section). If this does not work yet, it could be because Cygwin recently changed the formatting of their mirror's folder structure to support both x86 and x64. Because of this, <code>setup.exe</code> downloaded before this change no longer work due to them looking for the ini at <code>ftp.someMirrorName.com\cygwin</code>, where the new location is <code>ftp.someMirrorName.com\cygwin\x86</code>. <br /><br />To resolve the issue, you can try to download <a href="http://cygwin.com/setup-x86.exe">setup-x86.exe</a> or <a href="http://cygwin.com/setup-x86_64.exe">setup-x86_64.exe</a> into the NVPACK/cygwin folder and use it instead of <code>setup.exe</code>.</td>
                </tr>
            </tbody>
        </table>
        <p>&#160;</p>
        <ol>
            <li value="1">Open <code>main.cpp</code> and insert a breakpoint by double-clicking on the left margin as shown below. (Alternatively, right-click and select <b>Toggle Breakpoint</b>.) The blue dot is an indication that the breakpoint has been set.<br /><br /><img src="images/native_android_fibo_breakpoint.png" /></li>
            <li value="2">Now hit the debug button on the toolbar. When the program starts you may be asked if you want to open the Debug Perspective, select Yes.<br /><br /><img src="images/native_android_eclipse_debug_perspective.png" /><br /></li>
            <li value="3">Once in the Debug perspective the program execution should stop at the breakpoint you have inserted.<br /><br /><table><col style="width: 35px;" /><col style="width: 660px;" /><tbody><tr><td style="background-color: #ffffe0;vertical-align: middle;text-align: center;"><img src="images/notebox.png" /></td><td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> If Eclipse complains that it can not find a source file, click on the <b>Locate File...</b> button, and browse to the location of the file.</td></tr></tbody></table><br /><a class="MCPopupThumbnailLink" href="images/native_android_fibo_debug_srcnotfound.png"><img class="MCPopupThumbnail img" data-mc-width="890" data-mc-height="218" src="images/native_android_fibo_debug_srcnotfound_thumb_600_0.png" style="mc-thumbnail: link;mc-thumbnail-max-width: 600px;mc-thumbnail-max-height: auto;" tabindex="" /></a></li>
            <li value="4">The Debug toolbar allows you to select what to do next — continue running the program, step into, or step over the function.<br /><br /><img src="images/native_android_eclipse_debug_toolbar.png" /></li>
            <li value="5">We will step into the Fibonacci function to see it working. Select <b>Step into</b> or equivalently press <b>F5</b>. The execution will move into the Fibonacci function. The Debug Perspective shows a great deal of information: the calling stack, the current local variables, and the source code. In addition you can add watches, inspect memory, and even disassemble the code.<br /><br /><a class="MCPopupThumbnailLink" href="images/native_android_fibo_debug_view.png"><img class="MCPopupThumbnail img" data-mc-width="1103" data-mc-height="505" src="images/native_android_fibo_debug_view_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a></li>
            <li value="6">Instead of computing Fibonacci of 10, let's compute Fibonacci of 15. In the local variables view, find the variable <b>n</b> and change its value from 10 to 15. After you are done, hit the <b>Resume</b> (F8) button.</li>
            <li value="7">You can even make breakpoints conditional: add a breakpoint to the Fibonacci function, right-click it and select <b>Breakpoint Properties... &gt; Common</b>, set <b>Condition:</b> to <b>n==5</b>, and resume debugger (<b>F8</b>); now the debugger should stop when the function has been called with <b>n</b> equals 5.</li>
        </ol>
        <p>In the previous steps, we left many details uncovered. Eclipse has an internal Makefile builder that creates the Makefile based on the sources that you add to the project. That is why we were able to build the program successfully. In addition, Eclipse has different build configurations for a project. In this example, both <b>Debug</b> and <b>Release</b> configurations were created. The Debug configuration builds the program for debugging, while the Release turns on compiler optimizations for the final program. If you want to change the build properties, right-click on the project, and press Alt + Enter (on Linux and Windows), or Cmd + I (on Mac) to bring up the properties sheet. Under <b>C/C++ Build</b>, you will find the build options.</p>
        <h3>Create your first Android Java Application</h3>
        <p>We will now create a similar Android project to run on our device. If this is the first time you develop an android application, it could be a good idea to visit first the <a href="http://developer.android.com/training/index.html">getting started page</a> for Android developers.</p>
        <ol>
            <li value="1">Open the Java perspective. An Android project is always a Java project with the possible addition of native code. (Later, we show projects that seem to be native-only, but in reality even they use Android Java runtime services.)</li>
            <li value="2">Select <b>File &gt; New &gt; Android Application Project</b>. In <i>Application Name:</i>, type <b>Fibonacci</b>. In <i>Project Name</i>, type <b>AndroidFibonacci</b>. This is the name of the project in Eclipse. We already have a Fibonacci project so we must choose a different name. Set the remaining properties as shown and click <b>Next</b>.<br /><br /><img src="images/native_android_eclipse_new_android_app_page1.png" /><br /><table><col style="width: 35px;" /><col style="width: 660px;" /><tbody><tr><td style="background-color: #ffffe0;vertical-align: middle;text-align: center;"><img src="images/notebox.png" /></td><td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> Don't use spaces in the project name, otherwise native debugging will fail to find the symbols.</td></tr></tbody></table></li>
            <li value="3">An <i>Activity</i> is Android's basic unit of user interaction. We will manually create an Activity, so uncheck the <b>Create Activity</b> box   and click <b>Finish</b>.<br /><br /><img src="images/native_android_eclipse_new_android_app_page2.png" /></li>
            <li value="4">You now have a basic Android project skeleton.<br /><br /><img src="images/native_android_fibo_project.png" /></li>
            <li value="5">We will now create a new Java class. Right-click on <code>src</code> and select <b>New &gt; Class</b>. Fill out the class properties as shown — we want to create a class that inherits from <code>android.app.Activity</code> within the <code>package com.nvidia.example.fibonacci</code>.<br /><br /><img src="images/native_android_fibo_new_class.png" /><br /></li>
            <li value="6">Open the <code>FibonacciActivity.java</code> and add a Fibonacci function to the class skeleton. Java doesn't have unsigned types, so we will use integers instead and handle negative numbers correctly. <br /><blockquote><pre class="prettyprint" xml:space="preserve">package com.nvidia.example.fibonacci;
import android.app.Activity;
public class FibonacciActivity extends Activity {
int Fibonacci( int n ) {<br />    if( n == 1 ) { return 1; }<br />    if( n &lt;= 0 ) { return 0; }<br />    return Fibonacci( n - 1 ) + Fibonacci ( n - 2 );<br />    }<br />}</pre></blockquote></li>
            <li value="7">We now have to create a simple UI to display our output. For this, we create a <a href="http://developer.android.com/reference/android/widget/TextView.html">TextView</a> widget inside the <a href="http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)">onCreate</a> method. Add following code for the <code>onCreate</code> method to the <code>FibonacciActivity</code> class: <blockquote><pre class="prettyprint">@Override<br />public void onCreate( Bundle savedInstance ) {<br />super.onCreate(savedInstance);<br />// Create the TextView<br />TextView tv = new TextView( this );<br />tv.setText( "Fibonacci(10) = " + Fibonacci( 10 ) );<br />setContentView( tv );<br />}</pre></blockquote><br /><table><col style="width: 35px;" /><col style="width: 660px;" /><tbody><tr><td style="background-color: #ffffe0;vertical-align: middle;text-align: center;"><img src="images/notebox.png" /></td><td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> After you copy and paste the code shown above, Eclipse will underline <code>Bundle</code> and <code>TextView</code>, and note them as undefined classes. These are Android framework classes that require an <code>import</code> declaration. To add the imports for these, hover the cursor over the underlined text, and select the import option from the possible fixes or press the shortcut combination Ctrl-Shift-M (Linux, Windows) or  CMD-SHFT-M (on Mac). Of course, you can also just type the imports in, too.<br /><blockquote><pre class="prettyprint">import android.app.Activity;<br />import android.os.Bundle;<br />import android.widget.TextView;</pre></blockquote></td></tr></tbody></table></li>
            <li value="8">All of our code has been written. Now we need to specify in the manifest which activity to launch for this application. There can be more than one activity within an application, and one of those can be marked as the main entry point. We have created a single activity so far, this will be our MAIN and LAUNCHER activity.<br /><br />Open <code>AndroidManifest.xml</code>. Eclipse will open the manifest editor. Select the <b>AndroidManifest.xml</b> tab to view the xml file.<br /><br /><img src="images/native_android_fibo_manifesttab.png" /><br /><br />Then replace the activity tag with the code shown below:<br /><br />:emphasize-lines: 2, 16-23<br /><br /><blockquote><pre class="prettyprint" xml:space="preserve">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br /> <span style="background-color: #ffffe0;">package="com.nvidia.example.fibonacci"</span><br /> android:versionCode="1"<br /> android:versionName="1.0" &gt;
<br />&lt;uses-sdk<br /> android:minSdkVersion="8"<br /> android:targetSdkVersion="16" /&gt;
<br />&lt;application<br /> android:allowBackup="true"<br /> android:icon="@drawable/ic_launcher"<br /> android:label="@string/app_name"<br /> android:theme="@style/AppTheme" &gt;<br /><br /><span style="background-color: #ffffe0;"> &lt;activity</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">  android:name=".FibonacciActivity"</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">  android:label="@string/app_name"&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">  &lt;intent-filter&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    &lt;action   android:name="android.intent.action.MAIN" /&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">  &lt;/intent-filter&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"> &lt;/activity&gt;</span><br /> &lt;/application&gt;<br />&lt;/manifest&gt;<br /></pre></blockquote><br />An <a href="http://developer.android.com/reference/android/content/Intent.html">Intent</a> describes an operation to be performed. Activities with certain intent filters can perform the operations described by the intents.</li>
            <li value="9">Now, we can run the application on the device. Make sure the device is connected an powered on. Right-click on the project name and select <b>Run As &gt; Android Application</b>. Alternatively, you can click the run button on the toolbar. The code will be built and packaged into an <code>.apk</code> file that is pushed to the device and launched. The first time you run the application, you will be shown the "Auto Monitor Logcat" dialog. Choose <i>Yes</i>. If the dialog does not appear, go to <b>Window &gt; Show View &gt; Other</b> and select Logcat.<br /><br /><img src="images/native_android_eclipse_automonitor_logcat.png" /> <br /><br />Once the application is run, you should see:<br /><br /><a class="MCPopupThumbnailLink" href="images/native_android_fibo_output.png"><img class="MCPopupThumbnail img" data-mc-width="1366" data-mc-height="768" src="images/native_android_fibo_output_thumb_600_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 600px;" tabindex="" /></a><br /><br />The Logcat window provides messages that can be used to identify possible errors in the application. It also shows a list of messages that are useful for debugging.</li>
        </ol>
        <p>This concludes our simple Java application tutorial.</p>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;">
                        <p><b>See also:</b> <![CDATA[ ]]></p>
                        <ol>
                            <li value="1">Google's <a href="http://developer.android.com/training/basics/firstapp/index.html">building your first app</a> tutorial guides you through the steps required for creating a new Android Project in Eclipse, building, and running the application on the device.</li>
                            <li value="2">For an in-depth look at an Android application life cycle, please see <a href="lifecycle_main.htm">How To:&#160;Develop Apps Using the Android Application Lifecycle</a>. </li>
                        </ol>
                    </td>
                </tr>
            </tbody>
        </table>
        <h3>Debugging with the debugger</h3>
        <p>Now that we have completed our first app, we will launch the debugger and trace execution of the Fibonacci function.</p>
        <ol>
            <li value="1">To avoid debugging the String construction, modify the code slightly as shown below and set a breakpoint on the line that calls Fibonacci (double-click on the left of the line):<br /><blockquote><pre class="prettyprint" xml:space="preserve">@Override<br />public void onCreate( Bundle savedInstance ) {
<br />    super.onCreate( savedInstance );
<br />    // Create the TextView<br />    TextView tv = new TextView( this );<br />    <span style="background-color: #ffffe0;">int fibo = Fibonacci( 10 );</span><br />    tv.setText( "Fibonacci(10) = " + fibo );<br />    setContentView( tv );<br />}</pre></blockquote></li>
            <li value="2">Click on the Debug button, and if prompted about the Debug Configuration, select <i>Android Application</i>. The application package will be recompiled and copied to the device. You might see a message saying the application is waiting for the debugger to connect, this is normal. You will be taken to the Debug Perspective and will see the application hit a breakpoint. Press <b>F5</b> to trace into the function call. (Note that you can click the images in this document to see them in full size.)<br /><br /><a class="MCPopupThumbnailLink" href="images/native_android_fibo_debug_view.png"><img class="MCPopupThumbnail img" data-mc-width="1103" data-mc-height="505" src="images/native_android_fibo_debug_view_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a><br /></li>
            <li value="3">Try changing the value of n and hit <b>F8</b> to continue running and see the displayed result.</li>
        </ol>
        <h3>Printing debug messages to the Android log</h3>
        <p>Android provides a system <a href="http://developer.android.com/reference/android/util/Log.html">log</a> mechanism for developers to use from their applications. The log has different levels of information:</p>
        <ul>
            <li value="1">V — verbose</li>
            <li value="2">D — debug</li>
            <li value="3">I — info</li>
            <li value="4">W — warning</li>
            <li value="5">E — error</li>
            <li value="6">F — fatal</li>
        </ul>
        <p>All messages in the log include the process id that generated it. We will now add logging to our Fibonacci application.</p>
        <ol>
            <li value="1">Go back to Java perspective, open <code>FibonacciActivity.java</code>, and add the highlighted lines:<br /><blockquote><pre class="prettyprint" xml:space="preserve"><span style="background-color: #ffffe0;">import android.util.Log;</span><br /><br />public class FibonacciActivity extends Activity {<br /><br /> <span style="background-color: #ffffe0;">private static final String TAG = "Fibonacci";</span><br /><br />	@Override<br />	public void onCreate( Bundle savedInstance ) {<br /><br /> <span style="background-color: #ffffe0;">Log.d( TAG, "onCreate called" );</span><br /><br />	    super.onCreate( savedInstance );<br /><br />	    // Create the TextView<br />	    TextView tv = new TextView( this );<br />	    int fibo = Fibonacci( 10 );<br />	    tv.setText( "Fibonacci(10) = " + fibo );<br />	    setContentView( tv );<br />}</pre></blockquote><br />Each LOG message has a TAG that comes very handy for filtering messages out. A good TAG is a name that relates to your activity.</li>
            <li value="2"> <a name="logcat"></a>Run the application and open the LogCat view in Eclipse to see the message. Go to <b>Window &gt; Show View &gt; LogCat</b>. If you don't see the <b>LogCat</b> option, go to <b>Window &gt; Show View &gt; Other...</b> and search for <b>LogCat</b>. The LogCat viewer can filter the messages by process or information level, and you can also search the log as it is being dumped.<br /><br /><img src="images/native_android_fibo_logcat.png" /></li>
            <li value="3">Alternatively, you can display the logcat in a console window by running adb, which can be found under the <code>android-sdk-[linux|windows|mac]/platform-tools</code> directory. <br /><blockquote><pre class="prettyprint">adb logcat -s Fibonacci:*</pre></blockquote><br />The <code>-s</code> makes the default filter silent and the <b>Fibonacci:*</b> tells logcat to enable the Fibonacci tagged messages.</li>
        </ol>
        <h3>Writing debug messages to a file</h3>
        <p>If you would like to write debug messages to a file, you need to be aware that in Android, every application runs under a different user id, and only a limited set of paths are writable by the application and visible to the user. If you are using a Tegra prototype device, you can create directory under <code>data</code> to store your log files. But on commercial devices, this location is usually protected and you will need to find a suitable user-accessible path. Android provides the means to do so. To keep it simple, let's add logging to a file we create in <b>external storage</b>. Don't get misled by the word <i>external</i> here, the <i>external storage</i> might not be the SD card. But files you write to external storage are not deleted when the application is uninstalled.</p>
        <ol>
            <li value="1">#. In <code>FibonacciActivity.java</code>, we will add code to write to a log file. We will create a <b>logWriter</b> class instance variable that we will use to write text messages to a file we will create. <br /><blockquote><pre class="prettyprint" xml:space="preserve"><span style="background-color: #ffffe0;">private FileWriter logWriter;</span><br /><br />@Override<br />public void onCreate( Bundle savedInstance ) {<br /><br />    Log.d( TAG, "onCreate called" );<br /><br />    super.onCreate( savedInstance );<br /><br /> <span style="background-color: #ffffe0;">try {</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	File path = Environment.getExternalStorageDirectory();</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	File logfile = new File( path, "fibo_log.txt" );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	logWriter = new FileWriter( logfile );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	Log.i( TAG, "Writing log to " + logfile );
</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">
    }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    catch( IOException e ) {</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	Log.e( TAG, "Couldn't open log file - reason " + e.getMessage() );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    }</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    logMessage( "FibonacciActivity.onCreate\n" );
</span><br />    // Create the TextView<br />    TextView tv = new TextView( this );<br />    int fibo = Fibonacci( 10 );<br />    tv.setText( "Fibonacci(10) = " + fibo );<br />    setContentView( tv );<br />}</pre></blockquote></li>
            <li value="2">Now, let's create the auxiliary function logMessage:<br /><blockquote><pre class="prettyprint" xml:space="preserve">private void logMessage( String msg ) {
<br />    if( logWriter != null ) {<br />	try {<br />	    logWriter.write( msg );<br />	}<br />	catch( IOException e ) {<br />	    Log.e( TAG, "Couldn't write message to log file - reason " + e.getMessage() );<br />	}<br />    }<br />}</pre></blockquote></li>
            <li value="3">Finally, we need to flush the file and close the writer when the Activity is paused.<br /><blockquote><pre class="prettyprint" xml:space="preserve">@Override<br />public void onPause() {<br />    logMessage( "FibonacciActivity.onPause\n" );
<br />    try {<br />	logWriter.close();<br />    }<br />    catch( IOException e ) {<br />	Log.e( TAG, "Failed to close log file - reason: " + e.getMessage() );<br />    }
<br />    super.onPause();<br />}</pre></blockquote></li>
            <li value="4">Modify the <code>AndroidManifest.xml</code> and indicate that the application requests permission to write to external storage.<br /><blockquote><pre class="prettyprint">&lt;!-- Before the application tag, add the requested permissions --&gt;<br /><span style="background-color: #ffffe0;">&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</span><br />&lt;application android:label="@string/app_name"</pre></blockquote></li>
            <li value="5">Build and run the application. Because each Android device might have a different path to the external storage, we print the location of the file to the system log.<br /><br /><img src="images/native_android_fibo_logfilename.png" /></li>
            <li value="6">To view the file, first pause or end the application so that the file is closed and it can be read. Then transfer it to the host computer by typing the command below on the command line (check the path from the log message). <br /><blockquote><pre class="prettyprint">adb pull /storage/sdcard0/fibo_log.txt</pre></blockquote></li>
        </ol>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>See also:</b> An explanation on <a href="http://developer.android.com/guide/topics/data/data-storage.html">Android storage</a>.
                    </td>
                </tr>
            </tbody>
        </table>
        <h3>Adding Native Android code</h3>
        <p>Using our <b>FibonacciActivity</b> as a starting point, we will add a native library that computes the Fibonacci function.</p>
        <ol>
            <li value="1">We first tell the project to build both C++ and Java code. Right-click on the project name, and select <b>Android Tools &gt; Add Native Support...</b> Set the library name to <code>libfibonacci.so</code>, and click on <b>Finish</b>.<br /><br /><img src="images/native_android_fibo_add_native.png" /></li>
            <li value="2">You will notice that Eclipse has now changed to the C++ Perspective. In addition, there is a new folder in the project tree called <code>jni</code> that contains <code>fibonacci.cpp</code> and <code>Android.mk</code>.<br /><br /><img src="images/native_android_fibo_jni_folder.png" /></li>
            <li value="3"><b>Android.mk</b> is a make file with the instructions on how to build our native sources. <br /><blockquote><pre class="prettyprint">LOCAL_PATH := $(call my-dir)<br /><br />include $(CLEAR_VARS)<br /><br />LOCAL_MODULE    := fibonacci<br />LOCAL_SRC_FILES := fibonacci.cpp<br /><br />include $(BUILD_SHARED_LIBRARY)</pre></blockquote><br />The <code>LOCAL_MODULE</code> gives the module name which in turn is used for the output filename. <code>LOCAL_SRC_FILES</code> contains the list of files to build, and finally, the <code>include</code> command is used to include the rules for building a shared library. The output of the build will be <code>libfibonacci.so</code>. This library needs to be explicitly loaded by the Java VM, as we show next.</li>
            <li value="4">Create a new file under the <code>jni</code> folder named <b>Application.mk</b>. Right-click on <code>jni</code> and select <b>New &gt; File</b>.<br /><br /><img src="images/native_android_fibo_add_application_mk.png" /><br /><br />While the <code>Android.mk</code> file defines module settings, the <code>Application.mk</code> file is used to define per-application settings that apply to all modules. Set the contents of the new file as shown below: <br /><blockquote><pre class="prettyprint">APP_ABI := armeabi-v7a<br />APP_PLATFORM := android-8</pre></blockquote><br />The <code>APP_ABI</code> line defines the target machine code instruction set. The default is <code>armeabi</code>, which corresponds to an ARM ISA with no hardware floating point support. To support hardware FPU instructions of more recent ARM processors, use <code>armeabi-v7a</code>. We also set the <code>APP_PLATFORM</code> to android-ver, where ver is the value of the <code>android::minSdkVersion</code> in the <code>AndroidManifest.xml</code>.    For <code>NativeActivity</code> support, a version at or above 9 is required, but this example uses a Java Activity.</li>
            <li value="5">Let's now modify the <b>FibonacciActivity</b> class and mark the Fibonacci function as native.  Comment out the original Java version of the Fibonacci function. We will also add a static method that loads the native library. <br /><blockquote><pre class="prettyprint" xml:space="preserve">public class FibonacciActivity extends Activity {<br /><br />    @Override<br />    public void onCreate( Bundle savedInstance ) {<br /><br />	super.onCreate( savedInstance );
<br />	// Create the TextView<br />	TextView tv = new TextView( this );<br />	int fibo = Fibonacci( 10 );<br />	tv.setText( "Fibonacci(10) = " + fibo );<br />	setContentView( tv );<br />    }
<br />    // Our native Fibonacci function<br />    native int Fibonacci( int n );<br />    static {<br />    System.loadLibrary( "fibonacci" );<br />}</pre></blockquote><br /><br />In our modified class, the Fibonacci function doesn't have an implementation, it is only marked as native.</li>
            <li value="6">Java VM machine relies on name mangling to link the Java native method with its actual implementation. You can use the <code>javah</code> utility to generate the function headers for you and avoid remembering the mangling rules. For this, you will first need to compile your project. Right-click on the project name and select <b>Build Project</b>.<br /><br /><img src="images/native_android_fibo_build_project.png" /></li>
            <li value="7">You will notice that even though the <code>fibonacci.cpp</code> is empty, the C++ builder is invoked successfully. There is no error telling us that the native method has not been implemented. This kind of error will be a Java Exception raised by the virtual machine. You can see it for yourself; if you try to run the application, it will crash. You can look at the error by browsing the <a href="#logcat">logcat</a>:<br /><br /><img src="images/native_android_fibo_unsatisfiedlinkererror.png" /><br /><br />If the LogCat window is too small, select the window and hit CTRL+M to expand the window, another CTRL+M brings back the other windows.  Double-clicking the tab also does the same thing.</li>
            <li value="8">To generate the proper function header, open a console, go to your project directory (where the <code>AndroidManifest.xml</code> file is located), and run <code>javah</code>. <br /><blockquote><pre class="prettyprint">javah -classpath ./bin/classes -d jni com.nvidia.example.fibonacci.FibonacciActivity</pre></blockquote><br />The output will be the file <code>jni/com_nvidia_example_fibonacci_FibonacciActivity.h</code>.<br /><br /><table><col style="width: 35px;" /><col style="width: 660px;" /><tbody><tr><td style="background-color: #ffffe0;vertical-align: middle;text-align: center;"><img src="images/notebox.png" /></td><td style="background-color: #ffffe0;vertical-align: middle;"><b>If it doesn't work:</b> We have found on some installations, that <code>javah</code> from a previous, non-Android Java installation was on the path before the one from Android toolkit.  If you encounter errors, type <code>which javah</code> to find which version is used. It should return a path within NVPACK.  On cygwin, we fixed this by editing <code>/home/&lt;user&gt;/.bash_profile</code> by adding a line: <br /><blockquote><pre class="prettyprint">PATH="/cygdrive/c/NVPACK/jdk1.6.0_24/bin:${PATH}"</pre></blockquote><br /></td></tr></tbody></table></li>
            <li value="9">Open the file <code>fibonacci.cpp</code> to continue working on our implementation. Create the Fibonacci function as shown and add an include for the new header. <br /><blockquote><pre class="prettyprint" xml:space="preserve">#include &lt;jni.h&gt;
<br />int Fibonacci( int n )<br />{<br />    if( n == 1 ) { return 1; }<br />    if( n &lt;= 0 ) { return 0; }
<br />    return Fibonacci( n - 1 ) + Fibonacci( n - 2 );<br />}</pre></blockquote></li>
            <li value="10">Copy and paste the function declaration from <code>jni/com_nvidia_example_fibonacci_FibonacciActivity.h</code> into <code>fibonacci.cpp</code>.  If you can't see the file in the <code>jni</code> folder, click the folder and press <b>F5</b> to refresh. The header file only contains the function declaration; in the cpp file you will have to actually call the function. To this aim, the entire function declaration has to be copied from the .h to the .cpp file (including the extern "C") and modified as in the highlighted lines. Our jni function will simply be a wrapper around the Fibonacci function. <br />. code-block:: c++<br />:emphasize-lines: 11,13<br /><blockquote><pre class="prettyprint">#ifdef __cplusplus<br />extern "C" {<br />#endif<br />/*<br />* Class:     com_nvidia_example_fibonacci_FibonacciActivity<br />* Method:    Fibonacci<br />* Signature: (I)I<br />*/<br />JNIEXPORT jint JNICALL Java_com_nvidia_example_fibonacci_FibonacciActivity_Fibonacci<br />( JNIEnv *env, jobject obj, jint n )<br />{<br />return Fibonacci( n );<br />}<br />#ifdef __cplusplus<br />}<br />#endif</pre></blockquote></li>
            <li value="11">That's it! Build the project and click the run button to see it running on the device.</li>
        </ol>
        <p>
            <table>
                <col style="width: 35px;" />
                <col style="width: 660px;" />
                <tbody>
                    <tr>
                        <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                            <img src="images/notebox.png" />
                        </td>
                        <td style="background-color: #ffffe0;vertical-align: middle;">
                            <p style="background-color: #ffffe0;vertical-align: middle;"><b>See also:</b>
                            </p>
                            <ol>
                                <li style="background-color: #ffffe0; vertical-align: middle;" value="1">The Android NDK documentation is located in your installed NDK under <code>android-ndk-r9c/docs</code>. The documentation is extensive and covers in detail the <code>Android.mk</code> and <code>Application.mk</code> files, plus the creation of reusable modules and prebuilt libraries to use on other projects. </li>
                                <li style="background-color: #ffffe0; vertical-align: middle;" value="2">There are multiple JNI tutorials available on the web that expand on the basic information we have presented here. In the next examples, we will expand more on JNI. </li>
                            </ol>
                        </td>
                    </tr>
                </tbody>
            </table>
        </p>
        <h3><a name="Debugging_native_app"></a>Debugging your native application</h3>
        <p>Now that we have built and deployed our mixed Java and native code Activity, we will show how to debug it. There are two Debug configurations that we can use. To debug Java code, we will debug as we did previously, by selecting <b>Debug As &gt; Android Application</b>. This configuration launches a debugger that attaches to the Java VM. For native code, we will instead use <b>Debug As &gt; Android Native Application</b>. This configuration now launches a <code>gdbserver</code> instance on the device that attaches to the application process.</p>
        <ol>
            <li value="1">To generate a binary library that is debugging-friendly, we need to modify the build command. Right-click on the <b>AndroidFibonacci</b> project, and select <b>Properties &gt; C/C++ Build</b>. Uncheck the <i>Use default build command option</i> and add the NDK_DEBUG=1 option to the  build command.<br /><br /><img src="images/native_android_fibo_build_ndkdebug.png" /> </li>
            <li value="2">To make switching between <b>Release</b> and <b>Debug</b> mode faster, you can use <b>Build Configurations</b>. Right now you only have a configuration called <b>Default</b>, which is basically a Release build configuration created for you by Eclipse. Right-click on the project name in the  Project Explorer pane, then <b>Build Configurations</b>, and you should see it:<br /><br /><img src="images/native_android_buildconfdefault.png" /><br /><br />Let's create our Debug configuration. In the menu shown above, choose <i>Manage...</i> instead of <i>Set Active</i>. In the new window click <b>New</b>. In the field <i>Name</i> of the window that just opened, type "Debug" and hit <b>OK</b>. If you go to the project's properties now, in the C/C++ Build, you should be able to pull down the Configuration menu and see your Debug configuration:<br /><br /><a class="MCPopupThumbnailLink" href="images/native_android_buildconfproperties.png"><img class="MCPopupThumbnail img" data-mc-width="848" data-mc-height="212" src="images/native_android_buildconfproperties_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a><br /><br />Select it and set the NDK_DEBUG=1 option as shown above. Hit <b>OK</b>. For Default configuration, re-select the <i>Use default build command option</i>. You can now switch between configurations by right-clicking the project's name and then <b>Build Configuration &gt; Set Active</b>:<br /><br /><img src="images/native_android_buildconfset.png" /></li>
            <li value="3">The debugger attaches to the application process asynchronously, which means that the application will start and run until the point when gdbserver attaches to the process. As a consequence, if you are trying to put a breakpoint in code that runs early in your application, the program flow might have already gone by that point when the debugger is finally attached. To debug our Fibonacci function that is called when the application starts, we will modify <code>fibonacci.cpp</code>: <blockquote><pre class="prettyprint" xml:space="preserve">#ifdef __cplusplus<br />extern "C" {<br />#endif<br /><br />#define WAIT_FOR_DEBUGGER<br /><br />jint JNI_OnLoad( JavaVM *vm, void *reserved )<br />{<br />#if defined(WAIT_FOR_DEBUGGER)<br />    volatile int _dbg = 1;<br />    while ( _dbg )<br />    {<br />    }<br />#endif<br /><br />    return JNI_VERSION_1_2;<br />}<br /><br />#ifdef __cplusplus<br />}<br />#endif</pre></blockquote><br />We have added a new function <b>JNI_OnLoad</b> with an infinite loop in it. <b>JNI_OnLoad</b> is called when the Java VM loads the library. The infinite loop will stall execution until the debugger is attached and we manually change the value of <code>_dbg</code>.  It is marked <i>volatile</i> to make sure the compiler does not optimize the variable away so we can clear it from the debugger.</li>
            <li value="4">Launch the application for Native debugging by right-clicking on the project and selecting <b>Debug As &gt; Android Native Application</b>. You will see the application starts, but there is no output on the screen. At the same time, Eclipse will change to the Debug Perspective.<br />If the debugging procedure does not start because of an <b>Unknown Application ABI</b> error, you can try to use <b>Debug as Android NDK Application</b>. Alternatively, you can set <code>android:minSdkVersion</code> and <code>android:targetSdkVersion</code> in <code>AndroidFibonacciManifest.xml</code>, and <code>APP_PLATFORM</code> in <code>Application.mk</code> to the same Android version. For instance, <code>android:minSdkVersion="19"</code>, <code>android:targetSdkVersion="19"</code> and <code>APP_PLATFORM := android-19</code>.</li>
            <li value="5">When the Debug perspective is open, hit the Suspend button (two yellow vertical bars). In the <b>Variables</b> tab, change the value of <code>_dbg</code> from 1 to 0; also set a breakpoint on the call to Fibonacci. Finally, let the program continue running by pressing <b>F8</b>; you should immediately hit the breakpoint you have just set.<br /><br /><a class="MCPopupThumbnailLink" href="images/native_android_fibo_native_debug_view.png"><img class="MCPopupThumbnail img" data-mc-width="1029" data-mc-height="702" src="images/native_android_fibo_native_debug_view_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-width: 700px;mc-thumbnail-max-height: auto;" tabindex="" /></a></li>
            <li value="6">You can now trace into the function by pressing <b>F5</b> or step over it by pressing <b>F6</b>. Change the value of n and press <b>F8</b> to continue with the execution.</li>
        </ol>
        <p>We are done! You have now seen the basics on how to do Java and native code debugging of Android applications running on the device from Eclipse.</p>
        <h3><a name="Printing_to_android_log_from_native_code"></a>Printing to Android log from native code</h3>
        <p>We can print debugging messages to the Android log from native code using the <code>__android_log_print</code> function.</p>
        <ol>
            <li value="1">Open <code>fibonacci.cpp</code> and add the following code at the top of the file. <blockquote><pre class="prettyprint">#if !defined(LOG_TAG)<br />#define LOG_TAG "Fibonacci"<br />#endif<br /><br />#define LOGV(...) __android_log_print( ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__ )<br />#define LOGD(...) __android_log_print( ANDROID_LOG_DEBUG  , LOG_TAG, __VA_ARGS__ )<br />#define LOGI(...) __android_log_print( ANDROID_LOG_INFO   , LOG_TAG, __VA_ARGS__ )<br />#define LOGW(...) __android_log_print( ANDROID_LOG_WARN   , LOG_TAG, __VA_ARGS__ )<br />#define LOGE(...) __android_log_print( ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__ )<br /><br />#include &lt;android/log.h&gt;</pre></blockquote><br />These are convenient macros that write to the log at the different information levels.</li>
            <li value="2">Add the following line to print the result of the Fibonacci function to the log. <br /><blockquote><pre class="prettyprint">JNIEXPORT jint JNICALL Java_com_nvidia_example_fibonacci_FibonacciActivity_Fibonacci<br />( JNIEnv *env, jobject obj, jint n )<br />{<br /> <span style="background-color: #ffffe0;">LOGV( "Fibonacci( %d ) = %d\n", n, Fibonacci( n ) );</span><br />    return Fibonacci( n );<br />}</pre></blockquote></li>
            <li value="3">Finally, we need to modify the <code>Android.mk</code> to link the log library into the project.<blockquote><pre class="prettyprint" xml:space="preserve">LOCAL_PATH := $(call my-dir)<br /><br />include $(CLEAR_VARS)<br /><br />LOCAL_MODULE    := fibonacci<br />LOCAL_SRC_FILES := fibonacci.cpp<br />LOCAL_LDLIBS    := -llog<br /><br />include $(BUILD_SHARED_LIBRARY)

</pre></blockquote>The <code>LOCAL_LDLIBS</code> directive specifies a list of system libraries provided by the NDK that we can link into our project. In the above example, the log library defines <code>__android_log_print</code>.</li>
            <li value="4">Comment out the definition of <code>WAIT_FOR_DEBUGGER</code> of the previous section (so you don't stay in an infinite loop), run the project, and verify that you can see the log message (either in eclipse or using adb).</li>
        </ol>
        <h3>Logging to a file from native code</h3>
        <p>When logging to a file from native code, we are still bound by the same restrictions we mentioned regarding user-accessible paths. Additionally, there is no native version of <code>Environment.getExternalStorageDirectory()</code> in the NDK, so we will have to pass the directory information from Java.</p>
        <ol>
            <li value="1">In <code>FibonacciActivity.java</code>, add a new native method that will enable native code logging into the specified file. <br /><blockquote><pre class="prettyprint">// Enable native logging to the given filename<br />native void enableNativeLogging( String filename );</pre></blockquote></li>
            <li value="2">In <code>onCreate</code>, we will call <code>enableNativeLogging</code>: <blockquote><pre class="prettyprint" xml:space="preserve">@Override<br />public void onCreate( Bundle savedInstance )<br />{<br />    super.onCreate( savedInstance );<br /><br />    [...]<br /><br /> <span style="background-color: #ffffe0;">// create the log file before calling Fibonacci()</span><br style="background-color: #ffffe0;" /> <span style="background-color: #ffffe0;">enableNativeLogging( Environment.getExternalStorageDirectory() + "/fibo_native_log.txt" );</span><br /><br />    TextView tv = new TextView( this );<br />    int fibo = Fibonacci( 10 );<br />    tv.setText( "Fibonacci(10) = " + fibo );<br />    setContentView( tv );<br />}</pre></blockquote></li>
            <li value="3">Now, let's implement the native side of <code>enableNativeLogging</code>. First, in the file <code>fibonacci.cpp</code>, we create an <code>ofstream</code>    with the scope of the entire source file to hold a handle to the log file (and include <code>fstream</code>): <br /><blockquote><pre class="prettyprint">#include &lt;fstream&gt;<br /><br />static std::ofstream gLogFile;</pre></blockquote><br />Second, we implement <code>enableNativeLogging</code>; this function calls into JNI to convert the Java string into a C-style string, opens the file, and then releases the allocated C-style string (do not forget to declare this as "extern C"):<blockquote><pre class="prettyprint"><br />/*<br />* Class:     com_nvidia_example_fibonacci_FibonacciActivity<br />* Method:    enableNativeLogging<br />* Signature: (Ljava/lang/String;)V<br />*/<br />JNIEXPORT void JNICALL Java_com_nvidia_example_fibonacci_FibonacciActivity_enableNativeLogging<br />( JNIEnv *env, jobject obj, jstring jfilename )<br />{<br />if( gLogFile.is_open() )<br />{<br />gLogFile.close();<br />}<br /><br />// Call JNI to convert the jstring into UTF 8 bit characters<br />const char* filename = env-&gt;GetStringUTFChars( jfilename, NULL );<br /><br />// If filename is non-empty, open the file<br />if( filename[0] != 0 )<br />{<br /><br />// Open the file<br />gLogFile.open( filename );<br />}<br /><br />// Release the string allocated by JNI<br />env-&gt;ReleaseStringUTFChars( jfilename, filename );<br />}</pre></blockquote><br />If you call the function a second time with an empty string, the file will be closed. In addition, because we are using <code>ofstream</code>, when the program exits, the <code>gLogFile</code> object will go out of scope and the file will be closed. Alternatively, you could add <code>enableNativeLogging( "" );</code> in the <code>onPause()</code> method in the Java side. <br /><br />Note that we repeated the step described above to generate the proper function header: in a console, go to your project directory and run javah: <br /><blockquote><pre class="prettyprint">javah -classpath ./bin/classes -d jni com.nvidia.example.fibonacci.FibonacciActivity</pre></blockquote></li>
            <li value="4">The Android NDK provides different C++ STL implementations. The default system STL is very limited. To enable the GNU STL implementation, and use the <code>ofstream</code> object, we need to modify the <code>Application.mk</code> file. By adding the following line to the <code>Application.mk</code>, the NDK build system will set the include path for the headers and add the static library.<br /><blockquote><pre class="prettyprint"># APP_STL<br />#    By default, the NDK build system provides C++ headers for the minimal<br />#    C++ runtime library (/system/lib/libstdc++.so) provided by the Android<br />#    system.<br />#<br />#    However, the NDK comes with alternative C++ implementations that you can<br />#    use or link to in your own applications. Define APP_STL to select one of<br />#    them. Examples are:<br />#<br />#       APP_STL := stlport_static    --&gt; static STLport library<br />#       APP_STL := stlport_shared    --&gt; shared STLport library<br />#       APP_STL := system            --&gt; default C++ runtime library<br /><br />APP_STL := gnustl_static</pre></blockquote></li>
            <li value="5">Let's make some entries to the file. Add the highlighted line in <code>fibonacci.cpp</code>: <br /><blockquote><pre class="prettyprint">int Fibonacci( int n )<br />{<br />gLogFile &lt;&lt; "Fibonacci called with " &lt;&lt; n &lt;&lt; std::endl;<br />[...]</pre></blockquote><br />Compile and run the program. Then let's use the <code>adb shell</code> from the command line to see what the file contains: <br /><blockquote><pre class="prettyprint">karip@mac:~$ adb shell<br />root@android:/ # cd /storage/<br />root@android:/storage # ls<br />sdcard0<br />sdcard1<br />root@android:/storage # cd sdcard0/<br />root@android:/storage/sdcard0 # cat fibo_native_log.txt<br />Fibonacci called with 10<br />Fibonacci called with 9<br />[... many lines removed ...]<br />Fibonacci called with 1<br />Fibonacci called with 0<br />root@android:/storage/sdcard0 #</pre></blockquote></li>
        </ol>
        <p>You can exit from the shell with <b>CTRL-D</b>. The many lines in the file demonstrate that although this recursive implementation of Fibonacci number calculation is elegant, it's not particularly efficient.</p>
        <h3>Calling Java functions from native code</h3>
        <p>We will extend our Fibonacci example further, by showing how to call Java methods from the native code. We will add the ability to log messages into the TextView, to mimic the behavior of a console application.</p>
        <ol>
            <li value="1">Open the file <code>FibonacciActivity.java</code>. Copy the new code for the FibonacciActivity class. We have moved the <code>TextView </code>to class member scope and we have added a function called <code>printToConsole </code>that we can call to append text to this <code>TextView</code>. In addition, we have a new native function called <code>FibonacciSequence</code>.<br /><blockquote><pre class="prettyprint" xml:space="preserve">public class FibonacciActivity extends Activity {<br /><br />    private TextView mConsoleText;<br /><br />    @Override<br />    public void onCreate( Bundle savedInstance ) {<br /><br />	super.onCreate( savedInstance );<br /><br />	// Create the TextView.<br />	mConsoleText = new TextView( this );<br />	setContentView( mConsoleText );<br /><br />	// Generate the Fibonacci sequence up to 10.<br />	FibonacciSequence( 10 );<br />    }<br /><br />    // Append new text to the consoleText TextView.<br />    private void printToConsole( String text ) {<br />      mConsoleText.setText( mConsoleText.getText() + text );<br />    }<br /><br />    // Native Fibonacci function - returns the nth Fibonacci number.<br />    native int Fibonacci ( int n );<br /><br />    // Computes the Fibonacci sequence up to n and prints<br />    // it through the print function.<br />    native void FibonacciSequence( int n );<br /><br />    static {<br />	System.loadLibrary( "fibonacci" );<br />    }<br />}</pre></blockquote></li>
            <li value="2">Since we have added a new native method we need to recreate the jni headers. First, build the project (this is necessary to compile the new Java code). Then, as we did in our previous tutorial, run javah:<br /><blockquote><pre class="prettyprint">javah -classpath ./bin/classes -d jni com.nvidia.example.fibonacci.FibonacciActivity</pre></blockquote><br />The file <code>jni/com_nvidia-example_fibonacci_FibonacciActivity.h</code> will be regenerated.</li>
            <li value="3">Now we need to add the new method to our native library. Open <code>fibonacci.cpp</code>, and copy and paste the newly added function header from <code>com_nvidia-example_fibonacci_FibonacciActivity.h</code>. Our implementation of FibonacciSequence will compute the Fibonacci numbers and print them to the TextView by calling the Java <code>printToConsole</code> method. The function code looks like this: <br /><blockquote><pre class="prettyprint">#include &lt;sstream&gt;
<br />[...]
<br />/*<br /> * Class:     com_nvidia_example_fibonacci_FibonacciActivity<br /> * Method:    FibonacciSequence<br /> * Signature: (I)V<br /> */<br />JNIEXPORT void JNICALL Java_com_nvidia_example_fibonacci_FibonacciActivity_FibonacciSequence<br />( JNIEnv *env, jobject obj, jint n )<br />{<br />    const char *methodName      = "printToConsole";<br />    const char *methodSignature = "(Ljava/lang/String;)V"; <br /><br />    jclass    objClass = ( jclass ) env-&gt;GetObjectClass( obj );<br />    jmethodID methodId = env-&gt;GetMethodID( objClass, methodName, methodSignature );<br /><br />    for( int i = 0; i &lt;= n; i++ )<br />    {<br /><br />	// Our string buffer for the output message.<br />	std::stringstream msg;<br /><br />	// Compute the current Fibonacci number.<br />	int fibo = Fibonacci( i );<br /><br />	// Create the msg to print.<br />	msg &lt;&lt; "Fibonacci(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; fibo &lt;&lt; std::endl;<br /><br />	// Create a jstring to send the message to the Java VM.<br />	jstring jtext = env-&gt;NewStringUTF( msg.str().c_str() );<br /><br />	// Call the Java class printToConsole method.<br />	env-&gt;CallVoidMethod( obj, methodId, jtext );<br /><br />	// Delete the local reference created by NewStringUTF<br />	// to allow the Java VM to garbage collect the jstring object.<br />	env-&gt;DeleteLocalRef( jtext );<br />    }<br />}</pre></blockquote><br />In order to call the <code>printToConsole</code> method on the passed Java object, we need to obtain its method ID from the Java VM. First, we ask for the <b>jclass</b> of the passed object by calling <code>GetObjectClass</code>. Then we obtain the <b>jmethodID</b> by calling <code>GetMethodID</code> and passing the corresponding <b>jclass</b> identifier, the method name, and the method signature. The method name is <i>printToConsole</i> and the signature <code>(Ljava/lang/String;)V</code>, which stands for a method returning void that takes an argument of type <code>java.Lang.String</code>.<br /><br />When we call the retrieved method, we cannot pass a pointer to char as an argument, we need to pass it a String object. The JNI environment has a helper function to do this. The <code>newStringUTF</code> function takes a <b>char *</b> and returns a <b>jstring</b> instance. We can then call the Java function using the <code>CallVoidMethod</code> and passing the obj, the method ID, and the string.</li>
            <li value="4">Comment out the #define WAIT_FOR DEBUGGER; we will not be attaching the debugger for this run.</li>
            <li value="5">Build the program and run it. You will see the following output:<br /><br /><a class="MCPopupThumbnailLink" href="images/android_fibo_sequence_output.png"><img class="MCPopupThumbnail img" data-mc-width="1366" data-mc-height="768" src="images/android_fibo_sequence_output_thumb_600_0.png" style="mc-thumbnail: link;mc-thumbnail-max-width: 600px;mc-thumbnail-max-height: auto;" tabindex="" /></a></li>
        </ol>
        <h3><a name="Creating_nativeactivity"></a>Creating a NativeActivity</h3>
        <p>Android provides a NativeActivity framework that can be used to run applications that are written entirely in native code. A NativeActivity can have event loops to receive user input, but will have no UI building blocks; it was developed for game developers and it is expected that the UI is built using OpenGL ES rendering.</p>
        <p>As an introduction to NativeActivity, we will write our Fibonacci example using this framework. Since there is no Java code, let's start with a new project. The following steps assume you have already performed all the previous tutorials.</p>
        <ol>
            <li value="1">From the Java perspective, create a new Android Application project as we did before. Set the Application, Project, and package names, and the minimum Android SDK version to 9.</li>
            <li value="2">Add Android Native Support. Set the <b>Library Name</b> to <code>libfibonacci.so</code>.</li>
            <li value="3">Create the <code>jni/Application.mk</code> file and set the <b>APP_ABI</b> to <code>armeabi-v7a</code>, and the Android platform to 14 (this is the first platform to support the NativeActivity). Also, set <b>APP_STL</b> to <code>gnustl_static</code>.<br /><blockquote><pre class="prettyprint">APP_ABI        := armeabi-v7a<br />APP_PLATFORM   := android-9<br />APP_STL        := gnustl_static</pre></blockquote></li>
            <li value="4">Now we have to setup the <code>AndroidManifest.xml</code>, which has a few extra settings for the NativeActivity. In the application section we specify that the app doesn't have any Java code. <br /><blockquote><pre class="prettyprint" xml:space="preserve">&lt;!-- We do not have Java code. Therefore android:hasCode is set to false. --&gt;<br />&lt;application android:label="@string/app_name"<br />	android:hasCode="false"&gt;</pre></blockquote><br />In the activity block (within the application block), we also need to add a few new items. First, the activity name needs to be set to **android.app.NativeActivity**. This is an actual Java class that exists in the Android SDK and that provides the glue for the native code. Then we configure the application to be fullscreen. And finally, we add a meta-data tag to indicate the name of the library containing the native code.<br /><blockquote><pre class="prettyprint" xml:space="preserve">&lt;application<br />    android:allowBackup="true"<br />    android:icon="@drawable/ic_launcher"<br />    android:label="@string/app_name"<br />    android:hasCode="false"<br />    android:theme="@style/AppTheme" &gt;
<br />    &lt;!-- Our activity is the built-in NativeActivity framework class.<br />	This will take care of integrating with our NDK code. --&gt;<br />    &lt;activity android:name="android.app.NativeActivity"<br />	android:label="@string/app_name"<br />	android:configChanges="orientation|keyboard|keyboardHidden"<br />	android:theme="@android:style/Theme.NoTitleBar.Fullscreen"&gt;
<br />    &lt;!-- Tell NativeActivity the name of or .so --&gt;<br />    &lt;meta-data android:name="android.app.lib_name"<br />	android:value="fibonacci" /&gt;
<br />    &lt;intent-filter&gt;<br />	&lt;action android:name="android.intent.action.MAIN" /&gt;<br />	&lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br />    &lt;/intent-filter&gt;<br />&lt;/activity&gt;</pre></blockquote></li>
            <li value="5">Open the <code>Android.mk</code>. Our library needs to statically link with the <code>android_native_app_glue</code> library, which is provided as a separate module, and against the shared system <code>log</code> and <code>android</code> libraries.<br /><blockquote><pre class="prettyprint" xml:space="preserve">LOCAL_PATH := $(call my-dir)
<br />include $(CLEAR_VARS)<br /><br />LOCAL_MODULE    := fibonacci<br />LOCAL_SRC_FILES := fibonacci.cpp<br />LOCAL_LDLIBS    := -llog -landroid<br />LOCAL_STATIC_LIBRARIES := android_native_app_glue
<br />include $(BUILD_SHARED_LIBRARY)
<br />$(call import-module, android/native_app_glue)</pre></blockquote></li>
            <li value="6">Now open <code>fibonacci.cpp</code> and add the following code:<br /><blockquote><pre class="prettyprint">#if !defined(LOG_TAG)<br />#define LOG_TAG "Fibonacci"<br />#endif
<br />#define LOGV(...) __android_log_print( ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__ )<br />#define LOGD(...) __android_log_print( ANDROID_LOG_DEBUG  , LOG_TAG, __VA_ARGS__ )<br />#define LOGI(...) __android_log_print( ANDROID_LOG_INFO   , LOG_TAG, __VA_ARGS__ )<br />#define LOGW(...) __android_log_print( ANDROID_LOG_WARN   , LOG_TAG, __VA_ARGS__ )<br />#define LOGE(...) __android_log_print( ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__ )
<br />#include &lt;android/log.h&gt;<br />#include &lt;android_native_app_glue.h&gt;
<br />int Fibonacci( int n )<br />{<br />    if ( n == 1 ) { return 1; }<br />    if ( n &lt;= 0 ) { return 0; }
<br />    return Fibonacci( n - 1 ) + Fibonacci( n - 2 );<br />}
<br />/**<br /> * This is the main entry point of a native application that is using<br /> * android_native_app_glue.  It runs in its own thread, with its own<br /> * event loop for receiving input events and doing other things.<br /> */<br />void android_main( struct android_app *state )<br />{<br />    // Make sure glue isn't stripped.<br />    app_dummy();<br /><br />    LOGV( "Fibonacci(10) = %d\n", Fibonacci( 10 ) );<br /><br />    // Event loop manager.<br />    // This is an empty event loop manager that waits for the user<br />    // to destroy the activity.<br />    while( 1 )<br />{<br />	// Read all pending events.<br />	int ident;<br />	int events;<br />	struct android_poll_source *source;<br /><br />	// Wait indefinitely for an event to occur.<br />	while( ( ident = ALooper_pollAll( -1, NULL, &amp;events, (void **)&amp;source ) ) &gt;= 0 )<br />	{<br /><br />	    // Process this event.<br />	    if( source != NULL )<br />	    {<br />		source-&gt;process( state, source );<br />	    } <br /><br />	    // Check if we are exiting.<br />	    if( state-&gt;destroyRequested != 0 )<br />	    {<br />		return;<br />	    }<br />	}<br />    }<br />}</pre></blockquote><br />The new code includes <code>android_native_app_glue.h</code> which provides the callbacks for notification of Activity life cycle events. In addition, the native application glue also requires an <b>android_main</b> function to be defined as the entry point for the application.<br /><br />To keep our sample short, we haven't created any UI, so we simply print the result of <code>Fibonacci(10)</code> to the Android log. In addition, we do have to process application events for the Activity to remain responsive. This is done inside the event manager loop, where we process all events until the user requests the app to exit. </li>
        </ol>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;">
                        <p style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> As the comment says, <code>app_dummy()</code> is needed to make sure that the glue module is not stripped. Without it, none of the methods in the module  would be called directly in the code, as the glue module is basically a bunch of callbacks, and the linker would strip the module, thus causing a RuntimeException.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>Try running the application. The screen will remain blank. Check the log message for the output. A handy way to find it quickly is to type in the LogCat search line <code>tag:fib</code>.</p>
        <h3>Logging to a file within a NativeActivity</h3>
        <p>In an earlier example, we showed how we could log into a file from native code, with the full path filename being provided by the Java application. When running a NativeActivity, we will find the path available to the application using the <b>externalDataPath</b> member of the <b>ANativeActivity</b> struct.</p>
        <ol>
            <li value="1">Open <code>fibonacci.cpp</code> and add the following includes and static declarations.<br /><blockquote><pre class="prettyprint">#include &lt;fstream&gt;<br />#include &lt;sstream&gt;<br />#include &lt;sys/stat.h&gt;<br />#include &lt;errno.h&gt;<br /><br />static std::ofstream gLogFile;</pre></blockquote></li>
            <li value="2">Then add the following code to the <code>android_main()</code> function to create and open the file. As opposed to what we have seen in the    Java framework, the path might not exist, so we will need to create it. For this, we have developed an auxiliary function, <code>MakePath()</code>, that we will present shortly.<br /><blockquote><pre class="prettyprint" xml:space="preserve">void android_main( struct android_app *state )<br />{<br />    // Make sure glue isn't stripped.<br />    app_dummy();<br /><br />    LOGV( "Fibonacci(10) = %d\n", Fibonacci( 10 ) );<br /><br />    std::stringstream filename;<br />    filename &lt;&lt; state-&gt;activity-&gt;externalDataPath &lt;&lt; "/" &lt;&lt; "fibo_native_log.txt";<br /><br />    MakePath( state-&gt;activity-&gt;externalDataPath, 0770 );<br /><br />    // Open the log file for output<br />    gLogFile.open( filename.str().c_str() );<br /><br />    if( gLogFile.is_open() )<br />    {<br />	LOGI( "Opened log file %s\n", filename.str().c_str() );<br />	gLogFile &lt;&lt; "FibonacciActivity Native log file " &lt;&lt; filename.str().c_str() &lt;&lt; std::endl;<br />    }<br />    else<br />    {<br />	LOGE( "Couldn't open the log file %s\n", filename.str().c_str() );<br />    }</pre></blockquote></li>
            <li value="3">Add the <code>MakePath</code> and <code>MakeDir</code> functions before <b>android_main</b>:<br /><blockquote><pre class="prettyprint" xml:space="preserve">static int MakeDir( std::string const &amp;path, mode_t mode )<br />{<br />    struct stat st;<br />    if( stat( path.c_str(), &amp;st ) != 0 )<br />    {<br />	if( mkdir( path.c_str(), mode ) != 0 &amp;&amp; errno != EEXIST )<br />	{<br />	    return false;<br />	}<br />    }<br />    else if( !S_ISDIR( st.st_mode ) )<br />    {<br />	errno = ENOTDIR;<br />	return false;<br />    }<br /><br />    return true;<br />}<br /><br />static bool MakePath( std::string const &amp;path, mode_t mode )<br />{<br />    std::string cstr( path );<br /><br />    int cpos = 0;<br />    int ppos = 0;<br />    bool success = true;<br />    while( success &amp;&amp; ( cpos = cstr.find_first_of( "/", ppos ) ) != std::string::npos )<br />    {<br />	if( cpos != ppos )<br />	{<br />	    /* Neither root nor double slash in path */<br />	    cstr[cpos] = '\0';<br />	    success = MakeDir( cstr, mode );<br />	    cstr[cpos] = '/';<br />	}<br />	ppos = cpos + 1;<br />    }<br /><br />    if( success )<br />    {<br />	success = MakeDir( path, mode );<br />    }<br /><br />    return success;<br />}</pre></blockquote></li>
            <li value="4">Modify the manifest to give the app the rights to write to external storage.</li>
            <li value="5">Try it out. Note that the log file is likely to go to a different directory, to one that is specific to this application. You can find which directory it is by looking into the log cat output. The path could be something like <code>/storage/sdcard0/Android/data/com.nvidia.nativeactfib/files/fibo_native_log.txt</code>, depending on the project name, etc.</li>
        </ol>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>See also:</b> <ol><li value="1">The NDK <code>native-activity</code> sample. You can find it under <code>android-ndk-r9b/samples/native-activity</code>. </li><li value="2">The OpenGL ES tutorial section. We will provide a framework for drawing from a NativeActivity and interacting with touch and other events.</li></ol></td>
                </tr>
            </tbody>
        </table>
        <p>&#160;</p>
        <p>&#160;</p>
        <div id="pagefooter">
            <br />
        </div>
        <hr style="height: 1px;" width="100%" size="0" align="center" />
        <script type="text/javascript" src="../../resources/stylesheets/run_prettify.js?lang=vb" autoload="true">
        </script>
        <p>&#160;</p>
        <div class="buttons inline-buttons clearfix topicToolbarProxy topicToolbarProxystyle.css" style="mc-topic-toolbar-items: ;">
            <div class="button-group-container-left">
                <button class="button needs-pie previous-topic-button" type="button" title="Navigate previous">
                    <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="previous topic" />
                </button>
                <div class="button current-topic-index-button disabled"><span class="sequence-index"></span> of <span class="sequence-total"></span></div>
                <button class="button needs-pie next-topic-button" type="button" title="Navigate next">
                    <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="next topic" />
                </button>
            </div>
        </div>
        <p> </p>
        <p><span style="color: #696969; font-size: 8pt;">NVIDIA&#160;AndroidWorks Documentation Rev. 1.2.150805 ©2015. NVIDIA Corporation. All Rights Reserved.</span>
        </p>
    </body>
</html>