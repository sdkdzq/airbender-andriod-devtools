<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Technologies|Mobile Technologies|Native Development on NVIDIA&#160;Android Devices">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>OpenGL ES 2.0</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../resources/stylesheets/style.css" rel="stylesheet" />
        <style>/*&lt;meta /&gt;*/

.button.previous-topic-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/navigate-previous.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.button.current-topic-index-button
{
	-pie-background: linear-gradient(#ffffff, #ececec);
}

.button.next-topic-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/navigate-next.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.needs-pie
{
	behavior: url('../../../Resources/Scripts/PIE.htc');
}

</style>
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
        <script src="../../../Skins/Default/Scripts/Toolbar.js">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop"><a href="../../../index.html#technologies/mobile/native_android_opengles.htm">Open topic with navigation</a>
        </p>
        <div class="MCBreadcrumbsBox_style.css_0"><span class="MCBreadcrumbsPrefix">You are here: </span><a class="MCBreadcrumbsLink" href="../technologies_aw.htm">Technologies</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="../mobile_technologies.htm">Mobile Technologies</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="native_android_development.htm">Native Development on NVIDIA&#160;Android Devices</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">OpenGL ES 2.0</span>
        </div>
        <p style="font-size: 8pt;">To view the latest NVIDIA&#160;AndroidWorks documentation, visit <a href="http://docs.nvidia.com/gameworks/index.html" target="_blank">http://docs.nvidia.com/gameworks/index.html</a>. </p>
        <h1><span class="SystemTitle">OpenGL ES 2.0</span>
        </h1><a name="kanchor125"></a>
        <div id="pageheader">
            <hr style="height: 1px;" width="100%" size="0" align="center" />
        </div>
        <p>OpenGL ES provides a fast way to display the camera images, possibly after some image processing, and allows building simple user interfaces.  In this section, we only cover 2D graphics using OpenGL ES 2.0. For 3D graphics, there are other tutorials available, as well as the NativeGlobe example provided in AndroidWorks.  From now on, we'll use GL as a shorthand for OpenGL ES 2.0. We also cover how to handle various Android events in a native program.</p>
        <p>We first show how to import an existing native GL project into your workspace, and then we show you how to create the same project from scratch. For the latter, we will follow similar steps to those described in <a href="native_android_devprocess.htm#Creating_nativeactivity">Creating a NativeActivity</a>, in case you need a more in-depth overview.</p>
        <h3><a name="Importing_existing_project"></a>Importing an existing project</h3>
        <p>Let's start the first GL application by importing an existing project to Eclipse. Start by importing <code>/tutorials/SimpleNativeGL</code> project. Open Eclipse, select <b>File &gt; Import &gt; Android &gt; Existing Android Code</b> into <code>Workspace*</code>, and browse into the <b>Root Directory</b> (<code>/tutorials/SimpleNativeGL</code>). You can copy the files into the project directory in the workspace if you want by selecting one of the boxes. Then hit <b>Finish</b>.</p>
        <p>If the project has the default name, like so:</p>
        <p>
            <img src="images/import_wrong_name.png" />
        </p>
        <p>... then you should rename the project (right-click the project and find the <b>Rename</b> option. Its location may vary depending on the operating system, could be under Refactor).</p>
        <p>
            <img src="images/project_rename.png" />
        </p>
        <p>In this case, we'll use the name SimpleNativeGL. Open the project in the <b>Package Explorer</b>. </p>
        <p>
            <img src="images/simple_gl_project.png" />
        </p>
        <p>The files and folders within the red rectangle are the ones you just imported, others were generated during the Import operation.</p>
        <p>As this is a native project, select the C/C++ perspective.</p>
        <p>
            <img src="images/c_cpp_perspective.png" />
        </p>
        <p>By default all Android projects are Java projects, let's convert ours to native by right-clicking the project in <b>Package Explorer</b> and selecting <b>New &gt; Convert to C/C++ Project</b>.  Select <b>Project Type</b> to be <code>Makefile project</code> and <b>Toolchain</b> to be <code>Android GCC</code>.</p>
        <p>
            <img src="images/convert_to_cpp.png" />
        </p>
        <p>Sometimes the project might be imported with the wrong Android version. In the Project Explorer, right-click on the project folder and choose <b>Properties</b>. In the <b>Android</b> tab, make sure that the version selected is at least <b>Android 4.0.3 (API 15)</b>:</p>
        <p>
            <img src="images/gl_setandroid.png" />
        </p>
        <p>Build the project (right-click <b>SimpleNativeGL &gt; Build Project</b>), and run it on your device (right-click <b>SimpleNativeGL &gt; Run As &gt; Android Application</b>). Try tapping the device display, and slide your finger along the display; the solid color that is displayed should vary depending on the touch location.</p>
        <h3><a name="Creating_project_from_scratch"></a>Creating a GL project from scratch</h3>
        <p>To learn how to create a project from scratch, let's go through the steps necessary to create the project we imported in the previous section. If you imported the project already, right-click on the project name in the Project Explorer pane, and click delete. If you copied the files into the workspace when importing the project, in the next window check the box <code>Delete project contents from disk (cannot be undone)</code>, and verify that you're deleting the correct project. As a general rule, you should always be extremely cautious when using this option, since Eclipse does not move the project to the trash, but rather deletes it completely. Finally click <b>OK</b>.</p>
        <p>From the Java perspective, let's create the new project:</p>
        <ul>
            <li value="1"> Create a new Android application (<b>File &gt; New &gt; Android Application Project</b>).</li>
            <li value="2"> Pick an <b>Application Name</b> (in this tutorial we are using <code>SimpleNativeGL</code> as a name).</li>
            <li value="3"> Change the <b>Minimum Required SDK</b> to <code>API 9: Android 2.3 (Gingerbread)</code>.</li>
            <li value="4"> Uncheck <i>Create custom launcher icon</i> and click <b>Next</b>.</li>
            <li value="5"> Uncheck <i>Create activity</i> and click <b>Finish</b>.</li>
        </ul>
        <p>Now we need to add native support:</p>
        <ul>
            <li value="1">Right-click on the project name and choose <b>Android tools &gt; Add Native Support ...</b></li>
            <li value="2">Leave the name of the lib as is and click <b>Finish</b>.</li>
        </ul>
        <p>Eclipse should now have switched to the C/C++ perspective. First let's modify the manifest file. Open the <code>AndroidManifest.xml</code> file, and switch to the <code>AndroidManifest.xml</code> tab at the bottom of the window to be able to see the actual xml code. Now, replace the code within the application block with the lines highlighted below:</p>
        <blockquote><pre class="prettyprint" xml:space="preserve">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br />    package="com.nvidia.example.simplenativegl"<br />    android:versionCode="1"<br />    android:versionName="1.0" &gt;
<br />    &lt;uses-sdk<br />	android:minSdkVersion="14"<br />	android:targetSdkVersion="15" /&gt;
<br /><span style="background-color: #ffffe0;">    &lt;!-- We do not have Java code. Therefore android:hasCode is set to false. --&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    &lt;application</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	android:hasCode="false"</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	android:label="@string/app_name" &gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	&lt;!--</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    Our activity is the built-in NativeActivity framework class.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    This will take care of integrating with our NDK code.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	--&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	&lt;activity</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    android:name="android.app.NativeActivity"</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    android:configChanges="orientation|keyboard|keyboardHidden"</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    android:label="@string/app_name"</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    android:theme="@android:style/Theme.NoTitleBar.Fullscreen" &gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    &lt;!-- Tell NativeActivity the name of our .so --&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    &lt;meta-data</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">		android:name="android.app.lib_name"</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">		android:value="SimpleNativeGL" /&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    &lt;intent-filter&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	        &lt;action android:name="android.intent.action.MAIN" /&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">		&lt;category android:name="android.intent.category.LAUNCHER" /&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"> 	    &lt;/intent-filter&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	&lt;/activity&gt;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    &lt;/application&gt;</span><br style="background-color: #ffffe0;" />&lt;/manifest&gt;</pre>
        </blockquote>
        <p>Now open the <code>Android.mk</code> file from the <code>jni</code> folder, and add the lines highlighted below:</p>
        <blockquote><pre class="prettyprint" xml:space="preserve">LOCAL_PATH := $(call my-dir)
<br />include $(CLEAR_VARS)
<br />LOCAL_MODULE    := SimpleNativeGL<br />LOCAL_SRC_FILES := SimpleNativeGL.cpp<br /><span style="background-color: #ffffe0;">LOCAL_LDLIBS    := -llog -landroid -lEGL -lGLESv2</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">LOCAL_STATIC_LIBRARIES := android_native_app_glue</span><br />include $(BUILD_SHARED_LIBRARY)
<br /><span style="background-color: #ffffe0;">$(call import-module, android/native_app_glue)</span></pre>
        </blockquote>
        <p>&#160;</p>
        <p>In addition to what we went over in the tutorial <a href="native_android_devprocess.htm#Creating_nativeactivity">Creating a NativeActivity</a>,  we need to link against the <i>EGL</i> and <i>GLESv2</i> libraries.</p>
        <p>In order to make sure that our application will be fully optimized, let's create an <code>Application.mk</code> file: right-click on the <code>jni</code> folder then <b>New &gt; File</b> and set the name to <code>Application.mk</code>. Open the new file and add to it the line:</p>
        <blockquote><pre class="prettyprint">APP_ABI := armeabi-v7a</pre>
        </blockquote>
        <p>Now we need to populate the file <code>SimpleNativeGL.cpp</code>. Let's start by including headers and creating macros to log events:</p>
        <blockquote><pre class="prettyprint">#include &lt;jni.h&gt;<br />#include &lt;errno.h&gt;<br />#include &lt;EGL/egl.h&gt;<br />#include &lt;GLES2/gl2.h&gt;<br />#include &lt;android/sensor.h&gt;<br />#include &lt;android_native_app_glue.h&gt;<br />#include &lt;android/log.h&gt;<br />#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, "SimpleNativeGL", __VA_ARGS__))<br />#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, "SimpleNativeGL", __VA_ARGS__))</pre>
        </blockquote>
        <p>Now let's create a <code>struct</code> to share the current status between different functions, and let's add placeholders for the functions we'll need to implement for this simple example:</p>
        <blockquote><pre class="prettyprint">/**<br /> * State of our app<br /> */<br />struct Engine<br />{<br />    // Save in the engine a pointer to the Android app<br />    struct android_app *app;<br />    // EGL Display, surface, and context<br />    EGLDisplay display;<br />    EGLSurface surface;<br />    EGLContext context;<br />    // States and touch locations<br />    bool animating;<br />    int  width;<br />    int  height;<br />    int  x_touch;<br />    int  y_touch;<br />};<br />/**<br /> * Initialize an EGL context for the current display<br /> */<br />static int engine_init_display( struct Engine *engine ){}
<br />/**<br /> * Draw the current frame on the display<br /> */<br />static void engine_draw_frame( struct Engine *engine ){}
<br />/**<br /> * Tear down the EGL context currently associated with the display<br /> */<br />static void engine_term_display( struct Engine *engine ){}
<br />/**<br /> * Process the input event<br /> */<br />static int32_t engine_handle_input( struct android_app *app, AInputEvent *event ){}
<br />/**<br /> * Process the next main command<br /> */<br />static void engine_handle_cmd( struct android_app *app, int32_t cmd ){}
<br />/**<br /> * This is the main entry point of a native application that is using<br /> * android_native_app_glue.  It runs in its own thread, with its own<br /> * event loop for receiving input events and doing other things.<br /> */<br />void android_main( struct android_app *app ){}</pre>
        </blockquote>
        <p>Now let's implement the different functions starting with the main:</p>
        <blockquote><pre class="prettyprint">/**<br /> * This is the main entry point of a native application that is using<br /> * android_native_app_glue.  It runs in its own thread, with its own<br /> * event loop for receiving input events and doing other things.<br /> */<br />void android_main( struct android_app *app )<br />{<br />    // Make sure glue isn't stripped<br />    app_dummy();<br /><br />    // Initialize the engine.<br />    // The engine stores the state and global variables of the application.<br />    struct Engine engine;<br />    memset( &amp;engine, 0, sizeof( engine ) );<br />    // The engine needs a pointer to app, e.g., to access the window data<br />    engine.app = app;<br /><br />    // Link the app to the engine and attach callbacks.<br />    // Store a pointer to the application engine for event handling.<br />    app-&gt;userData     = &amp;engine;<br />    // Callback for handling application status changes<br />    app-&gt;onAppCmd     = engine_handle_cmd;<br />    // Callback for handling touch input<br />    app-&gt;onInputEvent = engine_handle_input;<br /><br />    // The core of the main is an infinite loop which waits for events<br />    // and redraws the frame when needed.<br />    while( 1 )<br />    {<br />	// read all pending events<br />	int events;<br />	struct android_poll_source *source;<br /><br />	// If not animating, we will block forever waiting for events.<br />	// If animating, we loop until all events are read, then continue<br />	// to draw the next frame of animation.<br />	while( ( ALooper_pollAll( engine.animating ? 0 : -1, NULL, &amp;events, ( void ** ) &amp;source ) ) &gt;= 0 )<br />	{<br />	    // Process this event.<br />	    // Depending on the event, app-&gt;onAppCmd or app-&gt;onInputEvent may be called.<br />	    if( source != NULL )<br />	    {<br />		source-&gt;process( app, source );<br />	    }<br /><br />	    // Check if we are exiting (e.g., user presses the back button)<br /> 	    if( app-&gt;destroyRequested != 0 )<br />	    {<br />		engine_term_display( &amp;engine );<br />		return;<br />	    }<br />	}<br /><br />	if( engine.animating )<br />	{<br />	    // Done with events; draw next animation frame.<br />	    // Drawing is synched with the screen update rate, so there<br />	    // is no need to do timing here.<br />	    engine_draw_frame( &amp;engine );<br />	}<br />    }<br />}</pre>
        </blockquote>
        <p>First, <code>app_dummy()</code> is called to make sure all the Android callbacks are not optimized away by the compiler (more about it <a href="http://blog.beuc.net/posts/Make_sure_glue_isn__39__t_stripped/">here</a>). Next, an instance of <code>struct Engine</code> is created to store the global data of this application, including a pointer back to<code> struct android_app*app</code>. The <code>app</code> stores a pointer to the Engine, as well as pointers to two callbacks defined below. The core of this function is an infinite loop that iterates between handling events such as touches, and drawing a frame.</p>
        <p>Before diving into the functions that perform the GL calls we need to implement the functions that handle the callback inputs:</p>
        <blockquote><pre class="prettyprint">/**<br /> * Process the input event<br /> */<br />static int32_t engine_handle_input( struct android_app *app, AInputEvent *event )<br />{<br />    // Get a local pointer to the engine that we stored in the application<br />    struct Engine *engine = ( struct Engine * ) app-&gt;userData;<br /><br />    // Analyze the type of event<br />    if( AInputEvent_getType( event ) == AINPUT_EVENT_TYPE_MOTION )<br />    {<br />	// If the user lifted the finger from the screen, stop updating<br />	int32_t action = AMotionEvent_getAction( event );<br />	if( action != AMOTION_EVENT_ACTION_MOVE )<br />	{<br />	    engine-&gt;animating = false;<br />	    return 1;<br />	}<br /><br />	// Otherwise get the touch position and set animation to true<br />	engine-&gt;x_touch = AMotionEvent_getX( event, 0 );<br />	engine-&gt;y_touch = AMotionEvent_getY( event, 0 );<br />	engine-&gt;animating = true;<br />	return 1;<br />    }<br /><br />    return 0;<br />}<br /><br />/**<br /> * Process the next main command<br /> */<br />static void engine_handle_cmd( struct android_app *app, int32_t cmd )<br />{<br />    // Get a local pointer to the engine that we stored in the application<br />    struct Engine *engine = ( struct Engine * ) app-&gt;userData;<br /><br />    // Analyze the command<br />    switch( cmd )<br />    {<br />    case APP_CMD_INIT_WINDOW:<br />	// The window is being shown, get it ready<br />	if( engine-&gt;app-&gt;window != NULL )<br />	{<br />	    // Initialize the engine based on the current display<br />	    engine_init_display( engine );<br />	    // Start drawing<br />	    engine_draw_frame( engine );<br />	}<br />	break;<br />    case APP_CMD_TERM_WINDOW:<br />	// The window is being hidden or closed, clean it up<br />	engine_term_display( engine );<br />	break;<br />    case APP_CMD_LOST_FOCUS:<br />	// When our app loses focus, we stop animating<br />	engine-&gt;animating = false;<br />	break;<br />    }<br />}</pre>
        </blockquote>
        <p>The GL calls happen in functions static int <code>engine_init_display(struct Engine *engine)</code>, <code>static void engine_draw_frame(struct Engine *engine)</code>, and <code>static void engine_term_display(struct Engine *engine)</code>.  The first one initializes GL context and drawing surface using the GL companion API EGL.</p>
        <blockquote><pre class="prettyprint">/**<br /> * Initialize an EGL context for the current display<br /> */<br />static int engine_init_display( struct Engine *engine )<br />{<br />    // initialize OpenGL ES and EGL<br />    EGLDisplay display = eglGetDisplay( EGL_DEFAULT_DISPLAY );<br /><br />    eglInitialize( display, 0, 0 );<br /><br />    // Specify the attributes of the desired configuration.<br />    // We select an EGLConfig with at least 8 bits per color component<br />    // that is compatible with on-screen windows.<br />    const EGLint attribs[] =<br />    { EGL_SURFACE_TYPE, EGL_WINDOW_BIT, EGL_BLUE_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_RED_SIZE, 8, EGL_NONE };<br /><br />    // Here, the application chooses the configuration it desires.<br />    // eglChooseConfig in general returns all the configurations compatible<br />    // with the attributes passed. In this sample, we have a very simplified<br />    // selection process, where we pick the first EGLConfig that matches<br />    // our criteria (by setting the third argument to 1).<br />    EGLConfig config;<br />    EGLint numConfigs;<br />    eglChooseConfig( display, attribs, &amp;config, 1, &amp;numConfigs );<br /><br />    // EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is<br />    // guaranteed to be accepted by ANativeWindow_setBuffersGeometry().<br />    // We can use it to make the ANativeWindow buffers to match.<br />    EGLint format;<br />    eglGetConfigAttrib( display, config, EGL_NATIVE_VISUAL_ID, &amp;format );<br /> <br />    // Set a native Android window to have the format configured by EGL<br />    ANativeWindow_setBuffersGeometry( engine-&gt;app-&gt;window, 0, 0, format );<br /><br />    // Create EGL surface and context<br />    EGLSurface surface = eglCreateWindowSurface( display, config, engine-&gt;app-&gt;window, NULL );<br />    EGLContext context = eglCreateContext( display, config, NULL, NULL );<br /><br />    // Use the surface and context we just created and configure the engine<br />    if( eglMakeCurrent( display, surface, surface, context ) == EGL_FALSE )<br />    {<br />	LOGW( "Unable to eglMakeCurrent" );<br />	return -1;<br />    }<br /><br />    // Get width and height of the surface<br />    EGLint w, h;<br />    eglQuerySurface( display, surface, EGL_WIDTH, &amp;w );<br />    eglQuerySurface( display, surface, EGL_HEIGHT, &amp;h );<br /><br />    // Store the app variables so the callbacks can access the data<br />    engine-&gt;display = display;<br />    engine-&gt;context = context;<br />    engine-&gt;surface = surface;<br />    engine-&gt;width   = w;<br />    engine-&gt;height  = h;<br /><br />    // Initialize GL state<br />    glEnable( GL_CULL_FACE );<br />    glDisable( GL_DEPTH_TEST );<br /><br />    return 0;<br />}</pre>
        </blockquote>
        <p>Now that we have initialized the engine, we can implement the function to draw frames. In this simple example, we will be just setting a solid background color based on the touch location: we set the green channel to zero, and the blue (red) channel is driven by the vertical (horizontal) position of the touch on the screen.</p>
        <blockquote><pre class="prettyprint">/**<br /> * Draw the current frame on the display<br /> */<br />static void engine_draw_frame( struct Engine *engine )<br />{<br />    if( engine-&gt;display == NULL ) { return; } // No display<br /><br />    // Set the clear color based on the touch location from the engine<br />    glClearColor( ( ( float ) engine-&gt;x_touch ) / engine-&gt;width,  // Red channel<br />		  0,                                              // Green channel<br />		  ( ( float ) engine-&gt;y_touch ) / engine-&gt;height, // Blue channel<br />		  1 );                                            // Alpha channel<br />    // Clear the screen to the color we just set<br />    glClear( GL_COLOR_BUFFER_BIT );<br /><br />    // Swap the buffers, which indicates we're done with rendering this frame<br />    eglSwapBuffers( engine-&gt;display, engine-&gt;surface );<br />    // LOGI( "Buffers swapped by eglSwapBuffers..." );<br />}</pre>
        </blockquote>
        <p>The last function that we need to implement cleans up the EGL structures at application exit:</p>
        <blockquote><pre class="prettyprint">/** <br /> * Tear down the EGL context currently associated with the display<br /> */<br />static void engine_term_display( struct Engine *engine )<br />{<br />    if( engine-&gt;display != EGL_NO_DISPLAY )<br />    {<br />	eglMakeCurrent( engine-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );<br />	if( engine-&gt;context != EGL_NO_CONTEXT )<br />	{<br />	    eglDestroyContext( engine-&gt;display, engine-&gt;context );<br />	}<br />	if( engine-&gt;surface != EGL_NO_SURFACE )<br />	{<br />	    eglDestroySurface( engine-&gt;display, engine-&gt;surface );<br />	}<br />	eglTerminate( engine-&gt;display );<br />    }<br />    engine-&gt;animating = false;<br />    engine-&gt;display   = EGL_NO_DISPLAY;<br />    engine-&gt;context   = EGL_NO_CONTEXT;<br />    engine-&gt;surface   = EGL_NO_SURFACE;<br />}</pre>
        </blockquote>
        <h3>Creating a GL project using the NVIDIA framework</h3>
        <p>In the previous example, we described how to create an application from scratch, using the GL API; for Tegra-based devices, NVIDIA offers a framework that greatly simplifies the process (the framework will probably work on other Android devices too, but we haven't tested that). We will now implement a project that is very similar to the previous one, but we will employ this helper, to show its basic usage. The app will still change the background color based on the x and y position of the touches but, in addition to that, it will also overlay different text if the app is in focus or paused. In order to perform the latter, we will process the events generated by the UI. If the application is in focus, we will display "Active mode!" and we will track the position of the touches. When the return button is pressed once, or the "Recent app" button is pressed, or the bottom right corner is pressed, the app will be considered paused, or out-of-focus, and the text will be changed to:</p>
        <blockquote><pre class="prettyprint">Auto-pause<br />Press back to quit<br />Tap window to resume</pre>
        </blockquote>
        <p>When the app is paused, unless a new event is generated, an additional 4 more frames are going to be rendered, and after that, nothing else will happen.</p>
        <p>To begin, we first create a project (<code>SimpleNativeGL_NV</code>) the same way we did before. Follow the first steps described above up to the part where we modified the <code>AndroidManifest.xml</code> file. The only difference in the manifest file is the name we give to the library:</p>
        <blockquote><pre class="prettyprint">[...]<br />&lt;!-- Tell NativeActivity the name of our .so --&gt;<br />&lt;meta-data android:name="android.app.lib_name"<br /><span style="background-color: #ffffe0;">	   android:value="SimpleNativeGL_NV" /&gt;</span><br />[...]</pre>
        </blockquote>
        <p>Now let's modify the <code>Android.mk</code> file in the <code>jni</code> folder of the project:</p>
        <blockquote><pre class="prettyprint">LOCAL_PATH := $(call my-dir)
<br />include $(CLEAR_VARS)
<br />LOCAL_MODULE    := SimpleNativeGL_NV<br />LOCAL_SRC_FILES := SimpleNativeGL_NV.cpp Engine.cpp<br />LOCAL_LDLIBS    := -lc -lm -llog -landroid -ldl -lGLESv2 -lEGL<br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">LOCAL_STATIC_LIBRARIES := nv_and_util nv_egl_util nv_bitfont nv_math nv_glesutil nv_hhdds nv_log nv_shader nv_file nv_thread</span><br />LOCAL_CFLAGS    += -std=gnu++0x
<br />include $(BUILD_SHARED_LIBRARY)
<br /><span style="background-color: #ffffe0;"># Add the folder with the NVIDIA helper, assuming we are at the nvsample_workspace</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-add-path, $(NVPACK_PATH)/TDK_Samples/tegra_android_native_samples_v10p14/libs/jni)
</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"># Import the modules from the NVIDIA helper</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_and_util)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_egl_util)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_bitfont)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_math)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_glesutil)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_hhdds)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_log)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_shader)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_file)</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">$(call import-module, nv_thread)</span></pre>
        </blockquote>
        <p>In addition to what we did in the example, we created in <a href="#Creating_project_from_scratch">Creating an OpenGL&#160;project from scratch</a>, here we are just linking against the NVIDIA libraries and importing the corresponding modules. Note that we are assuming again that you are working in the <code>$NVPACK_PATH/nvsample_workspace</code> workspace. If not, you will have to change the pointer to the NVIDIA helper folder. Because we will create a class called <code>Engine</code>, we added the corresponding source file to the list of <code>LOCAL_SRC_FILES</code>.</p>
        <p>Also, we need the fonts for the text we will overlay on the screen. We can get them from the <code>assets</code> folder of other projects in the workspace. For instance, in the Project Explorer, expand the folder <b>NativeBasic &gt; assets</b>.  Copy the two <code>*.abc</code> and <code>*.dds</code> files to the <code>asset</code>s folder of our project (in total, you should be copying 4 files).  Dragging-and-dropping with holding ALT within Eclipse Project Explorer is probably the easiest way to do this.</p>
        <p>Finally, to make sure that our application is fully optimized, we need the <code>Application.mk</code>. You can create it like we did in <a href="#Creating_project_from_scratch">Creating an OpenGL&#160;project from scratch</a>, or copy it directly from the other project. Because we want to use smart pointers of the new C++ 11 STL, we need to add a line to indicate we will be using the GNU STL implementation:</p>
        <blockquote><pre class="prettyprint">APP_ABI := armeabi-v7a<br /><span style="background-color: #ffffe0;">APP_STL := gnustl_static</span></pre>
        </blockquote>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> The use of C++ 11 features, like <code>std::unique_ptr</code>, requires the compiler flag <code>-std=gnu++0x</code> and GCC version 4.6, which is the default compiler in NDK r8b. The compiler flags are given under <code>LOCAL_C_FLAGS</code> in the <code>Android.mk</code> file.</td>
                </tr>
            </tbody>
        </table>
        <p>We will now create a class expanding the Engine <code>struct</code> from the previous example, and we will move much of the code to it.</p>
        <p>In the <b>Project Explorer</b> pane, right-click on the <code>jni</code> folder and then <b>New &gt; Class</b>. In the <i>Class name</i> field, type <b>Engine</b> and then click <b>Finish</b>. Eclipse has now created for us both the header and source files for the class. Let's start from the header file:</p>
        <blockquote><pre class="prettyprint">#ifndef __ENGINE_H<br />#define __ENGINE_H
<br />// Includes for the NVIDIA helper libraries<br />#include &lt;nv_and_util/nv_native_app_glue.h&gt;<br />#include &lt;nv_egl_util/nv_egl_util.h&gt;
<br />// Logging macros<br />#define APP_NAME "SimpleNativeGL_NV"<br />#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG,APP_NAME, __VA_ARGS__))<br />#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, APP_NAME, __VA_ARGS__))<br />#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, APP_NAME, __VA_ARGS__))
<br />#define FRAMES_TO_RENDER 4
<br />/**<br /> *  This is the engine which implements the required callback functions,<br /> *  as well as a few utility functions.<br /> *  This implementation relies on the NVIDIA utilities.<br /> */<br />class Engine<br />{<br />public:<br />    /**<br />     * The constructor saves a pointer to the engine and to the callback<br />     * functions in the Android app. It also initializes the nv_shader library.<br />     */<br />    Engine( NvEGLUtil&amp; egl, struct android_app *app );
<br />    /**<br />     * The destructor mainly frees the allocated BitFonts.<br />     */<br />    ~Engine();
<br />    /**<br />     * The application can be active or paused. This function returns<br />     * false when the application is paused.<br />     */<br />    bool isActiveMode()<br />    {<br />	return mActiveMode;<br />    }
<br />    /**<br />     * Render the frame, after checking what the status of the Android app is.<br />     * Interactible should be true if the app is running, it is active, focused,<br />     * and has a valid surface.<br />     */<br />    void updateFrame( bool interactible );
<br />protected:
<br />    /**<br />     *  Wrapper to handle commands generated by the UI.<br />     */<br />    static void handleCmdThunk( struct android_app *app, int32_t cmd );
<br />    /**<br />     * Handle commands.<br />     */<br />    void handleCommand( int cmd );
<br />    /**<br />     * Wrapper to handle input events generated by the UI.<br />     */<br />    static int32_t handleInputThunk( struct android_app *app, AInputEvent *event );
<br />    /**<br />     * Handle inputs.<br />     */<br />    int handleInput( AInputEvent *event );
<br />    /* Auxiliary functions */
<br />    /**<br />     * Set mActiveMode; we use mActiveMode to keep track of whether the app is actually<br />     * running or paused. Examples of when the app is paused is when the user has pressed<br />     * the back button, the "Recent apps" button, or the time at the bottom right corner<br />     * of the screen.<br />     */<br />    void setActiveMode( bool running );
<br />    /**<br />     * If the app's window had been resized returns true and forces the frame to be<br />     * rendered.<br />     */<br />    bool checkWindowResized();
<br />    /**<br />     * Resets the number of frames that need to be rendered.<br />     */<br />    void requestForceRender()<br />    {<br />	// Even when no events are generated, we required that the system still renders<br />	// FRAMES_TO_RENDER frames.<br />	mForceRender = FRAMES_TO_RENDER;<br />    }
<br />    /*<br />     * Check if we are done rendering frames.<br />     */<br />    bool isForcedRenderPending()<br />    {<br />	// mForceRender is decremented every time a frame is rendered and<br />	// reinitialized to FRAMES_TO_RENDER when a new event is generated<br />	// by the UI<br />	return mForceRender &gt; 0;<br />    }
<br />    /**<br />     * This is the actual method which renders the frame.<br />     * It returns false if either EGL was not ready to render or<br />     * the UI could not be initialized.<br />     */<br />    bool renderFrame( bool allocateIfNeeded );
<br />    /**<br />     * Initialize the UI<br />     * Returns true if the UI was initialized, false if the fonts could not be<br />     * initialized.<br />     */<br />    bool initUI();
<br />    /**<br />     * If there is a pending window resize, perform it and return true.<br />     */<br />    bool resizeIfNeeded();
<br />    /* Variables */<br />    struct android_app *mApp; // Pointer to the Android app<br />    NvEGLUtil &amp;mEgl;          // NvEGLUtil is the NVIDIA wrapper to EGL<br />    bool  mResizePending;     // Is there a window-resize pending?<br />    bool  mActiveMode;        // Is the app active or has it been paused?<br />    bool  mUiInitialized;     // Has the UI been initialized?<br />    void *mUiText[2];         // We need this variable to get a pointer to the bftext objects<br />    int   mTouchX, mTouchY;   // Position of the touch event<br />    int   mForceRender;       // This variable counts how many more frames we want<br />   			      // to render in case no new requests are generated.<br />};
<br />#endif // __ENGINE_H</pre>
        </blockquote>
        <p>The comments and the naming of methods and variables should be self-explanatory. Open <code>Engine.cpp</code> so we can look at the implementation of the different methods, starting with the includes, constructor and destructor:</p>
        <blockquote><pre class="prettyprint">#include "Engine.h"
<br />// Includes for GL and EGL<br />#include &lt;EGL/egl.h&gt;<br />#include &lt;EGL/eglplatform.h&gt;<br />#include &lt;GLES2/gl2.h&gt;
<br />// Includes for the NVIDIA helper libraries<br />#include &lt;nv_and_util/nv_native_app_glue.h&gt;<br />#include &lt;nv_egl_util/nv_egl_util.h&gt;<br />#include &lt;nv_bitfont/nv_bitfont.h&gt;<br />#include &lt;nv_shader/nv_shader.h&gt;
<br />Engine::Engine( NvEGLUtil&amp; egl, struct android_app *app )<br />		: mEgl( egl ), mApp( app ), mResizePending( false ), mActiveMode( true ),<br />		  mForceRender( 4 ), mUiInitialized( false )<br />{<br />    // Save a pointer to the engine in the Android app<br />    app-&gt;userData = this;
<br />    // Save pointers to the implementation of the callback functions in the<br />    // Android app<br />    app-&gt;onAppCmd     = &amp;Engine::handleCmdThunk;<br />    app-&gt;onInputEvent = &amp;Engine::handleInputThunk;
<br />    // Initialize the nv_shader library<br />    nv_shader_init( app-&gt;activity-&gt;assetManager );
<br />    // Initialize the pointers to the bftext objects<br />    mUiText[0] = NULL;<br />    mUiText[1] = NULL;
}
<br />Engine::~Engine()<br />{<br />    // Free the allocated BitFonts<br />    NVBFTextFree( mUiText[1] );<br />    NVBFTextFree( mUiText[0] );<br />    NVBFCleanup();<br />}</pre>
        </blockquote>
        <p>In the code above, we used some of the NVIDIA libraries, such as an EGL utility. There is no comprehensive documentation of the libraries, but the code is commented pretty well.  Let's study what the EGL utility is made of.  Place the cursor on <code>NvEGLUtil</code> on the argument list of the Engine constructor and hit <b>F3</b> (or CTRL-click [CMD-click on Mac]).  This should take you to the definition of that object in <code>nv_egl_util.h</code>.  If the indexer worked correctly, you could now do the same thing to toggle between the declaration and definition of some member function, such as <code>swap()</code>.  You can always toggle between the header and implementation files with CTRL-TAB.  To get the indexer working for <code>nv_egl_util.h</code>, you'd need to go to <b>Project Properties &gt; C/C++ General &gt; Paths and Symbols &gt; Source Locations</b> and link the folder to where the <code>nv_egl_util.cpp</code> file is (it is in  <code>$NVPACK_PATH/TDK_Samples/tegra_android_native_samples_v10p14/libs/jni/nv_egl_util</code>).</p>
        <p>In any case, browsing these two files allows you to see how the <code>NvEGLUtil</code> class works.</p>
        <p>So far, it is pretty much like before, with the exception that we initialize the <code>nv_shader</code> library. Now we need to write the functions that handle commands from the UI. In the constructor we linked the <code>app-&gt;onAppCmd</code> callback to the method <code>Engine::handleCmdThunk()</code>; this method just gets a pointer to the engine object from the app and calls a method which actually handles the commands.</p>
        <blockquote><pre class="prettyprint">void Engine::handleCmdThunk( struct android_app *app, int32_t cmd )<br />{<br />    // Get a pointer to the Engine we stored in the Android app<br />    Engine *engine = ( Engine * ) app-&gt;userData;<br />    if( engine ) { engine-&gt;handleCommand( cmd ); }<br />}<br /><br />void Engine::handleCommand( int cmd )<br />{<br />    switch( cmd )<br />    {<br />    case APP_CMD_INIT_WINDOW:<br />	// The window is being shown, get it ready.<br />	// Note that on ICS, the EGL size will often be correct for the new size here,<br />	// but on HC it will not be.  We need to defer checking the new res until the<br />	// first render with the new surface! Fall through to the window resize case.<br /><br />    case APP_CMD_WINDOW_RESIZED:<br />	// A command to resize the window was issued, we need to<br />	// redraw it with its new size.<br />	mEgl.setWindow( mApp-&gt;window );<br />	requestForceRender();<br />	break;<br /><br />    case APP_CMD_TERM_WINDOW:<br />	// The window is being hidden or closed, clean it up.<br />	mEgl.setWindow( NULL );<br />	break;<br /><br />    case APP_CMD_GAINED_FOCUS:<br />	// The app window gained focus we need to start rendering it.<br />	requestForceRender();<br />	break;<br /><br />    case APP_CMD_LOST_FOCUS:<br />	// The app window lost focus so we need to pause it.<br />	// Fall through to the command pause case.<br /><br />    case APP_CMD_PAUSE:<br />	// Move out of active mode if we are in it. But if we are<br />	// in another dialog mode, leave it as-is.<br />	if( mActiveMode )<br />	{<br />	    setActiveMode( false );<br />	}<br />	// Note that we still want to render in background.<br />	requestForceRender();<br />	break;
<br />    case APP_CMD_CONFIG_CHANGED:<br />	// ICS does not appear to require this, but on GB phones,<br />	// not having this causes rotation changes to be delayed or<br />	// ignored when we're in a non-rendering mode like autopause.<br />	// The forced renders appear to allow GB to process the rotation.<br />	requestForceRender();<br />	break;<br />    }<br />}</pre>
        </blockquote>
        <p>Similarly, in the constructor we also linked the <code>app-&gt;onInputEvent</code> callback to the method <code>Engine::handleInputThunk()</code>. Finally the method <code>Engine::handleInput()</code> analyzes the event and either updates the touch positions or, if the event was a "back button" event, handles pausing the app or closing it.</p>
        <blockquote><pre class="prettyprint">/**<br /> * Process the next input event.<br /> */<br />int32_t Engine::handleInputThunk( struct android_app *app, AInputEvent *event )<br />{<br />    // Get a pointer to the Engine we stored in the Android app<br />    Engine *engine = ( Engine * ) app-&gt;userData;<br />    if( !engine ) { return 0; }<br />    return engine-&gt;handleInput( event );<br />}<br />int Engine::handleInput( AInputEvent *event )<br />{<br />    // We only handle motion events (touchscreen) and key (button/key) events<br />    int32_t eventType = AInputEvent_getType( event );<br />    if( eventType == AINPUT_EVENT_TYPE_MOTION )<br />    {<br />	int32_t action = AMOTION_EVENT_ACTION_MASK &amp; AMotionEvent_getAction( ( const AInputEvent * ) event );<br /><br />	// A tap on the screen takes us out of autopause into active mode if<br />	// we were paused.  No other touch processing is done.<br />	if( action == AMOTION_EVENT_ACTION_DOWN )<br />	{<br />	    setActiveMode( true );<br />	    return 0;<br />	}<br />	mTouchX = AMotionEvent_getX( event, 0 );<br />	mTouchY = AMotionEvent_getY( event, 0 );<br />	return 1;<br />    }<br />    else if( eventType == AINPUT_EVENT_TYPE_KEY )<br />    {<br />	int32_t code = AKeyEvent_getKeyCode( ( const AInputEvent * ) event );<br />	// If we are in active mode, we eat the back button and move into<br />	// pause mode.  If we are already in pause mode, we allow the back<br />	// button to be handled by the OS, which means we'll be shut down.<br />	if( ( code == AKEYCODE_BACK ) &amp;&amp; mActiveMode )<br />	{<br />	    setActiveMode( false );<br />	    return 1;<br />	}<br />    }<br />    return 0;<br />}</pre>
        </blockquote>
        <p>Now let's write the methods that perform the actual rendering of the frame. We will have an auxiliary method, <code>Engine::updateFrame()</code> that looks at the status of our application and decides whether we need to render or not.</p>
        <blockquote><pre class="prettyprint">void Engine::updateFrame( bool interactible )<br />{<br />    if( interactible )<br />    {<br />	// Each frame, we check to see if the window has resized.  While the<br />	// various events we get _should_ cover this, in practice, it appears<br />	// that the safest move across all platforms and OSes is to check at<br />	// the top of each frame.<br />	checkWindowResized();
<br />	// Time stands still when we're auto-paused, and we don't<br />	// automatically render.<br />	if( mActiveMode )<br />	{<br />	    // This will try to set up EGL if it isn't set up.<br />	    // When we first set up EGL completely, we also load our GLES resources.<br />	    // If these are already set up or we succeed at setting them all up now, then<br />	    // we go ahead and render.<br />	    renderFrame( true );<br />	}<br />	else if( isForcedRenderPending() ) // forced rendering when needed for UI, etc.<br />	{<br />	    // This forces to change the text when paused.<br />	    renderFrame( true );<br />	}<br />    }<br />    else<br />    {<br />	// Even if we are not interactive, we may be visible, so we<br />	// HAVE to do any forced renderings if we can.  We must also<br />	// check for resize, since that may have been the point of the<br />	// forced render request in the first place!<br />	// Basically it still renders even if the application is not in focus.<br />	if( isForcedRenderPending() &amp;&amp; mEgl.isReadyToRender( false ) )<br />	{<br />	    checkWindowResized();<br />	    renderFrame( false );<br />	}<br />    }<br />}</pre>
        </blockquote>
        <p>The actual method that performs rendering has to first make sure that everything is ready (EGL ready and UI initialized), then it clears the buffer to the color selected with the touch position and renders the text:</p>
        <blockquote><pre class="prettyprint">bool Engine::renderFrame( bool allocateIfNeeded )<br />{<br />    // Check that EGL is ready to render. If allocateIfNeeded<br />    // try to also allocate the rendering surface and bind it<br />    // to the context.<br />    if( !mEgl.isReadyToRender( allocateIfNeeded ) )<br />    {<br />	return false;<br />    }<br /><br />    // Make sure that the UI is initialized<br />    if( !initUI() )<br />    {<br />	LOGW( "Could not initialize UI - assets may be missing!" );<br />	ANativeActivity_finish( mApp-&gt;activity );<br />	return false;<br />    }<br />    resizeIfNeeded();<br /><br />    // Set up viewport<br />    glViewport( ( GLint ) 0, ( GLint ) 0,<br />	        ( GLsizei )( mEgl.getWidth() ), ( GLsizei )( mEgl.getHeight() ) );<br /><br />    // Set the clear color...<br />    glClearColor( ( ( float ) mTouchX ) / ( ( float ) mEgl.getWidth() ), 0,<br />	          ( ( float ) mTouchY ) / ( ( float ) mEgl.getHeight() ), 1 );<br />    // ...and clear.<br />    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );<br /><br />    /* Do some rendering here */<br />    // ...<br /><br />    // Render the bitfont text overlaid here<br />    NVBFTextRenderPrep();<br />    void *uiText = mUiText[mActiveMode ? 1 : 0];<br />    if( uiText ) { NVBFTextRender( uiText ); }<br /><br />    // Done rendering overlaid text.<br />    NVBFTextRenderDone();<br /><br />    if( mForceRender &gt; 0 ) { mForceRender--; }<br /><br />    // Swap the buffers, which indicates we're done with rendering this frame<br />    mEgl.swap();<br /><br />    return true;<br />}</pre>
        </blockquote>
        <p>The magic for rendering with OpenGL ES now happens inside <code>NVBFTextRender()</code> function. If you browse to its declaration and definition as explained above, you can see that  it is here that the maths for placing the text is calculated, the texture map containing the text characters is bound, and so forth.  We will go deeper into all that in the next tutorial.</p>
        <p>Let's now look at the code for the method <code>Engine::initUI()</code>. It's pretty simple, actually. We just initialize the bitfonts and set the properties for the text that we need to overlay. Note that EGL was initialized at the Engine construction, as the <code>NvEGLUtil &amp;mEgl</code> was</p>
        <p>constructed. It's also here that <code>NVBFInitialize()</code> is called, it sets up the vertex and fragment  shaders that are used to render the text strings with GL.</p>
        <blockquote><pre class="prettyprint">bool Engine::initUI()<br />{<br />    // The UI might have been initialized already<br />    if( mUiInitialized ) { return true; }
<br />    // Initialize the NVIDIA bitfonts<br />    const int NUM_FONTS = 2;<br />    static NvBool fontsSplit[NUM_FONTS] = { 1, 1 }; // all are split<br />    static const char *fontFiles[NUM_FONTS] = { "courier+lucida_256.dds", "utahcond+bold_1024.dds" };<br />    if( NVBFInitialize( NUM_FONTS, (const char**) fontFiles, fontsSplit, 0 ) )<br />    {<br />	LOGW( "Could not initialize NvBitFont" );<br />	return false;<br />    }
<br />    // Allocate the text for the paused mode and set its properties<br />    mUiText[0] = NVBFTextAlloc();<br />    NVBFTextSetFont( mUiText[0], 2 ); // should look up by font file name<br />    NVBFTextSetSize( mUiText[0], 32 );<br />    NVBFTextSetColor( mUiText[0], NV_PC_PREDEF_WHITE );<br />    NVBFTextSetString( mUiText[0], NVBF_COLORSTR_RED NVBF_STYLESTR_BOLD "Auto-pause:\n" NVBF_<br />    TYLESTR_NORMAL<br />    NVBF_COLORSTR_BLUE "Press back to quit\nTap window to resume" );
<br />    // Allocate the text for the active mode and set its properties<br />    mUiText[1] = NVBFTextAlloc();<br />    NVBFTextSetFont( mUiText[1], 2 ); // should look up by font file name<br />    NVBFTextSetSize( mUiText[1], 32 );<br />    NVBFTextSetColor( mUiText[1], NV_PC_PREDEF_WHITE );<br />    NVBFTextSetString( mUiText[1], NVBF_COLORSTR_GREEN "Active mode!" );
<br />    mUiInitialized = true;
<br />    return true;<br />}</pre>
        </blockquote>
        <p><code>Engine::resizeIfNeeded()</code> basically just sets the height and width of the window and changes the text size accordingly:</p>
        <blockquote><pre class="prettyprint">bool Engine::resizeIfNeeded()<br />{<br />    // Do we need to resize?<br />    if( !mResizePending ) { return false; }
<br />    // Get the target height and width<br />    int w = mEgl.getWidth();<br />    int h = mEgl.getHeight();<br />    int textHeight = ( w &gt; h ) ? ( h / 16 ) : ( w / 16 );
<br />    // Change the resolution to the correct width and height<br />    NVBFSetScreenRes( w, h );
<br />    // Also update the size of the characters<br />    if( mUiText[0] )<br />    {<br />	NVBFTextSetSize( mUiText[0], textHeight );<br />	NVBFTextCursorAlign( mUiText[0], NVBF_ALIGN_CENTER, NVBF_ALIGN_BOTTOM );<br />	NVBFTextCursorPos( mUiText[0], w / 2, h / 2 );<br />    }<br />    if( mUiText[1] )<br />    {<br />	NVBFTextSetSize( mUiText[1], textHeight );<br />	NVBFTextCursorAlign( mUiText[1], NVBF_ALIGN_CENTER, NVBF_ALIGN_CENTER );<br />	NVBFTextCursorPos( mUiText[1], w / 2, h / 2 );<br />    }
<br />    mResizePending = false;
<br />    return true;<br />}</pre>
        </blockquote>
        <p>And finally, a couple of auxiliary functions:</p>
        <blockquote><pre class="prettyprint">void Engine::setActiveMode( bool running )<br />{<br />    if( mActiveMode != running )<br />    {<br />	requestForceRender();<br />    }<br />    mActiveMode = running;<br />}
<br />bool Engine::checkWindowResized()<br />{<br />    if( mEgl.checkWindowResized() )<br />    {<br />	mResizePending = true;<br />	requestForceRender();<br />	LOGI( "Window size change %dx%d", mEgl.getWidth(), mEgl.getHeight() );<br />	return true;<br />    }<br />    return false;<br />}</pre>
        </blockquote>
        <p>We are done with implementing the engine, we now only need to write the main function of our application. Fill <code>SimpleNativeGL_NV.cpp</code> in the <code>jni</code> folder with this code:</p>
        <blockquote><pre class="prettyprint">// EGL and GL includes<br />#include &lt;EGL/egl.h&gt;<br />#include &lt;EGL/eglplatform.h&gt;<br />#include &lt;GLES2/gl2.h&gt;<br /><br />// NVIDIA helper includes<br />#include &lt;nv_and_util/nv_native_app_glue.h&gt;<br />#include &lt;nv_egl_util/nv_egl_util.h&gt;<br /><br />#include &lt;memory&gt;<br /><br />#include "Engine.h"<br /><br />/**<br /> * This is the main entry point of a native application that is using<br /> * android_native_app_glue.  It runs in its own thread, with its own<br /> * event loop for receiving input events and doing other things.<br /> */<br />void android_main( struct android_app *app )<br />{<br />    // Make sure glue isn't stripped.<br />    app_dummy();<br /><br />    std::unique_ptr&lt;NvEGLUtil&gt; egl( NvEGLUtil::create() );<br />    if( !egl )<br />    {<br />	// If we have a basic EGL failure, we need to exit immediately; nothing else we can do<br />	nv_app_force_quit_no_cleanup( app );<br />	return;<br />    }<br /><br />    std::unique_ptr&lt;Engine&gt; engine( new Engine( *egl, app ) );<br /><br />    // Loop waiting for stuff to do.<br />    while( nv_app_status_running( app ) )<br />    {<br />	// Read all pending events.<br />	int ident;<br />	int events;<br />	struct android_poll_source *source;<br /><br />	// If not rendering, we will block forever waiting for events.<br />	// If animating, we loop until all events are read, then continue<br />	// to draw the next frame of animation.<br />	while( ( ident = ALooper_pollAll( ( ( nv_app_status_focused( app ) &amp;&amp; engine-&gt;isActiveMode() ) ? 1 : 250 ),<br />				NULL, &amp;events, ( void ** ) &amp;source ) )<br />				&gt;= 0 )<br />	{<br />	    // If we timed out, then there are no pending messages.<br />	    if( ident == ALOOPER_POLL_TIMEOUT ) { break; }<br /><br />	    // Process this event.<br />	    if( source != NULL )                { source-&gt;process( app, source ); }<br /><br />	    // Check if we are exiting.  If so, dump out.<br />	    if( !nv_app_status_running( app ) ) { break; }<br />	}<br /><br />	// Update the frame, which optionally updates time and animations<br />	// and renders.<br />	engine-&gt;updateFrame( nv_app_status_interactable( app ) );<br />    }<br />}</pre>
        </blockquote>
        <p>Let's try to compile the application: right-click on the project folder and select <b>Build project</b>. Even if you followed this tutorial to the letter, you will get errors::</p>
        <blockquote><pre class="prettyprint">../jni/SimpleNativeGL_NV.cpp:32: undefined reference to `Engine::Engine(NvEGLUtil&amp;, android_app*)'<br />../jni/SimpleNativeGL_NV.cpp:64: undefined reference to `Engine::updateFrame(bool)'<br />../obj/local/armeabi-v7a/objs/SimpleNativeGL_NV/SimpleNativeGL_NV.o: In function `std::default_delete&lt;Engine&gt;::operator()(Engine*) const':<br />../android-ndk-r8b/sources/cxx-stl/gnu-libstdc++/4.6/include/bits/unique_ptr.h:63: undefined reference to `Engine::~Engine()'</pre>
        </blockquote>
        <p>But we did include all the necessary includes. And, in fact, if you <b>CTRL + click</b> on the name of the class in the <code>SimpleNativeGL_NV.cpp</code> file, Eclipse will take you to the <code>Engine.h</code> file. The problem is that we didn't include all the source files in the <code>Android.mk</code> file, so the compiler does not know that <code>Engine.cpp</code> is part of the project. However, since we don't want to have to modify that file every time, we add a new class, and we will use wildcards instead. We will replace the line:</p>
        <blockquote><pre class="prettyprint">LOCAL_SRC_FILES := SimpleNativeGL_NV.cpp Engine.cpp</pre>
        </blockquote>
        <p>with the following:</p>
        <blockquote><pre class="prettyprint">MY_PREFIX           := $(LOCAL_PATH)/<br />MY_SOURCES          := $(wildcard $(LOCAL_PATH)/*.cpp)<br />MY_SOURCES          += $(wildcard $(LOCAL_PATH)/*.c)<br />LOCAL_SRC_FILES     += $(MY_SOURCES:$(MY_PREFIX)%=%)</pre>
        </blockquote>
        <p>Now let's run the application. Right-click on the project folder and select <b>Run as &gt; Android Application</b>. You should see the text "Active!" on the screen. Drag your finger around. Notice that if you click on the back button, for instance, the text will change to reflect that the application has been paused.</p>
        <p>This concludes our second GL tutorial.</p>
        <h3>Using shaders in your GL project</h3>
        <p>In this third and last GL tutorial,  we will expand the previous tutorial to explore the use of shaders. We will create an application which will load an image as a texture; depending on which button the user presses, we will show either the texture loaded or a filtered version of it. For simplicity we will implement a <a href="http://en.wikipedia.org/wiki/Sobel_filter">Sobel filter</a> along the vertical direction of the image. In addition, we also display the time spent in active mode by the app; this counter will stop when the application is paused. To get an idea, these are screenshots for the two states:</p>
        <p><a class="MCPopupThumbnailLink" href="images/gl_plainshader.png"><img class="MCPopupThumbnail img" data-mc-width="1366" data-mc-height="768" src="images/gl_plainshader_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a>
        </p>
        <p><a class="MCPopupThumbnailLink" href="images/gl_filtershader.png"><img class="MCPopupThumbnail img" data-mc-width="1366" data-mc-height="768" src="images/gl_filtershader_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a>
        </p>
        <p>We assume that you have the previous project in your workspace already, and we will build on it. If you don't have it, please import the <code>SimpleNativeGL_NV</code> project from the <code>tutorials</code> folder.</p>
        <p>First we will create the background texture from a regular image. We will need to create a <code>DDS</code> file.</p>
        <table>
            <col style="width: 35px;" />
            <col style="width: 660px;" />
            <tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> DDS (<a href="http://en.wikipedia.org/wiki/DirectDraw_Surface">DirectDraw Surface</a>) is a compressed picture format whose main advantage over standard <code>jpeg</code> or <code>png</code> formats is that it is not decompressed before it's loaded in memory, and is then decompressed in hardware at access time. Standard image files are usually decompressed (in software) before they are loaded into memory, and use more space.</td>
                </tr>
            </tbody>
        </table>
        <p>To manipulate DDS files, you can use the tools of your choice. GIMP plus the DDS plugin is one option. NVIDIA also provides <a href="https://developer.nvidia.com/legacy-texture-tools">a set of basic tools</a> for Windows, we will start there. You can download the DDS utilities, and convert <a href="http://us.download.nvidia.com/downloads/cool_stuff/wallpapers/NVIDIA_Claw/Claw3_1280x800.jpg">this image</a> typing in a shell::</p>
        <blockquote><pre class="prettyprint">nvdxt -file Claw3_1280x800.jpg -output nvidia_green.dds</pre>
        </blockquote>
        <p>(Note that the input image does not necessarily need to be \*.jpeg, but there are some constraints as far as the width and height of the input image go.)</p>
        <p>On Ubuntu, you can install the <code>gimp-dds</code> package, open <code>Claw3_1280x800.jpg</code> using GIMP and save it as <code>nvidia_green.dds</code> selecting DXT5 compression. Now copy <code>nvidia_green.dds</code> in your project's <code>assets</code> folder.</p>
        <p>Next we want to create the shaders, one to render the original texture and one to render the Sobel image. We need to create 4 different files in the <code>assets</code> folder (from the Project Explorer pane, right-click on the <code>assets</code> folder, then <b>New &gt; File</b>):</p>
        <blockquote><pre class="prettyprint">plain.vert<br />plain.frag<br />filter.vert<br />filter.frag</pre>
        </blockquote>
        <p>We will draw a 2D rectangle with vertices (0,0), (1,0), (1,1) and (0,1) to render the texture on screen. The texture coordinates for each vertex are the same as their position, drawing the entire texture into the 2D rectangle. The vertex shader will map each vertex of the rectangle to clip coordinates in the range [-1,1] on each axis. The vertex shaders are going to be identical for both the filtered and the original images. Open <code>plain.vert</code> and fill it  with this code (and do the same for <code>filter.vert</code>):</p>
        <blockquote><pre class="prettyprint">attribute vec2 aPos;      // Position, in screen coordinates, passed as an attribute.<br />attribute vec2 aUV;       // Position, in texture coordinates, passed as an attribute.<br />varying   vec2 vTexCoord; // Texture coordinates to be passed as varying to<br />		          // the fragment shader.<br />uniform   vec2 uViewMin;  // Bottom left corner of the rectangle in clip coordinates<br />uniform   vec2 uViewDim;  // x,y dimensions of the rectangle in clip coordinates<br /><br />/*<br /> * This vertex shader maps a 2D vertex to clip coordinates coordinates in the<br /> * range specified by uViewMin and uViewDim<br /> */<br />void main()<br />{<br />    // Convert to clip coordinates.<br />    gl_Position = vec4( uViewMin.x + aPos.x * uViewDim.x, uViewMin.y + aPos.y * uViewDim.y, 0.0, 1.0 );<br /><br />    // Pass the texture coordinates untouched.<br />    vTexCoord = aUV;<br />}</pre>
        </blockquote>
        <p>Essentially, this vertex shader maps the 2D rectangle to a region of the clip coordinate space.</p>
        <p>The fragment shader to render the original image is very simple too, as it only sets <code>gl_FragColor</code> to the value of the texture at the corresponding position (copy this in the <code>plain.frag</code> file):</p>
        <blockquote><pre class="prettyprint">precision lowp float;         // Use low precision for floats.<br /><br />uniform sampler2D  uTex;      // The texture sampler.<br />varying vec2       vTexCoord; // Texture coordinates.<br /><br />/*<br /> * This shader just shows the texture on the screen, without performing any<br /> * processing to it. Therefore, just set the color of the fragment to the<br /> * same as in the texture.<br /> */<br />void main()<br />{<br />    // Look up the texture and set the fragment color<br />    // to the same value of the texture at the same location.<br />    gl_FragColor = texture2D( uTex, vTexCoord );<br />}</pre>
        </blockquote>
        <p>The next step is to implement the fragment shader that performs Sobel filtering. Open the <code>filter.frag</code> fragment shader and paste in the following code:</p>
        <blockquote><pre class="prettyprint">precision mediump float;      // Use medium precision for floats.<br /><br />uniform vec2      uD;         // Step size corresponding to one pixel in the texture.<br />uniform sampler2D uTex;       // The texture sampler.<br />varying vec2      vTexCoord;  // Texture coordinates.<br /><br />/*<br /> * This very simple fragment performs a y gradient (using Sobel filter)<br /> * to the green channel of the texture.<br /> */<br />void main()<br />{<br />    // The origin is in the bottom-left corner, with the y axis<br />    // pointing up, and the texture coordinates go from 0 to 1.<br /><br />    // Let's accumulate fragment color using a vertical Sobel filter,<br />    // with the following weights:<br />    //<br />    //   -1   -2   -1<br />    //    0    0    0<br />    //    1    2    1<br />    //<br />    // We get the colors by doing lookups in the texture map with<br />    // correct offsets.<br /><br />    gl_FragColor  =       texture2D( uTex, vTexCoord + vec2( -uD.x, -uD.y ) );<br />    gl_FragColor += 2   * texture2D( uTex, vTexCoord + vec2(   0.0, -uD.y ) );<br />    gl_FragColor +=       texture2D( uTex, vTexCoord + vec2(  uD.x, -uD.y ) );<br />    gl_FragColor -=       texture2D( uTex, vTexCoord + vec2( -uD.x,  uD.y ) );<br />    gl_FragColor -= 2   * texture2D( uTex, vTexCoord + vec2(   0.0,  uD.y ) );<br />    gl_FragColor -=       texture2D( uTex, vTexCoord + vec2(  uD.x,  uD.y ) );<br /><br />    // ... and compute the color of this fragment (we set alpha to 1).<br />    gl_FragColor.r = gl_FragColor.b = gl_FragColor.g;<br />    gl_FragColor.a = 1.0;<br />}</pre>
        </blockquote>
        <p>We are done with the shaders implementation. Now we will add a couple of classes to our project. Right-click on the <code>jni</code> folder under your project in the Project Explorer pane and select <b>New &gt; Class</b>. Call it <code>RectShader</code> (unselect the <i>Namespace</i> checkbox if necessary).</p>
        <p>We will use this class to load and compile the shaders. In fact, we will create one object of this class per shader. An instance of the <code>RectShader</code> class will compute the uniforms for the vertex shader based on the current screen size and the choice of stretching or preserving the image aspect ratio. When stretching is selected the 2D rectangle is mapped to the entire clip coordinates range. If we choose to keep the aspect ratio, the corresponding origin and size of the rectangle in clip space coordinates is computed and assigned to the <code>uViewMin</code> and <code>uViewDim</code> uniforms. The header file of our class will be:</p>
        <blockquote><pre class="prettyprint">#ifndef RECT_SHADER_H_<br />#define RECT_SHADER_H_<br /><br />#include &lt;GLES2/gl2.h&gt;<br /><br />class RectShader<br />{<br />public:<br /><br />    enum ImageRowStorage<br />    {<br />	// First byte in memory is top row<br />	STORAGE_TOP_FIRST   = 1,<br /><br />	// First byte in memory is bottom row<br />	STORAGE_BOTTOM_FIRST = 2<br />    };<br /><br />    enum ImageAspectRatio<br />    {<br />	ASPECT_RATIO_KEEP       = 1,<br />	ASPECT_RATIO_STRETCH    = 2<br />    };<br /><br />    /*<br />     * Load, compile, and initialize the shader.<br />     */<br />    RectShader( const char *shaderName );<br /><br />    /*<br />     * Destructor.<br />     */<br />    virtual ~RectShader();<br /><br />    /*<br />     * Set the attributes of the shader.<br />     */<br />    virtual void bind( const GLfloat vertices[8], const GLfloat uvs[8] );<br /><br />    /*<br />     * Set the viewport aspect ratio<br />     */<br />    virtual void setViewportAspectRatio( float width, float height );<br /><br />   /*<br />    * To be called when the image size changes. Set image size, which<br />    * row is zero, and if we want to keep the aspect ratio or fit the image<br />    */<br />   virtual void setImageSize( float width, float height,<br />   			ImageRowStorage zeroRow = STORAGE_TOP_FIRST,<br />   			ImageAspectRatio aspect = ASPECT_RATIO_STRETCH );<br /><br />    /*<br />     * Returns the origin of the rectangle in viewport coordinates<br />     */<br />    void getOrigUniform( GLfloat origin[2] ) const;<br /><br />    /*<br />     * Returns the dimensions of the rectangle in viewport coordinates<br />     */<br />    void getDimUniform( GLfloat dim[2] ) const;<br />protected:<br /><br />    /* Functions */<br /><br />    /*<br />     * Computes the viewport region the current image will take.<br />     */<br />    void updateClipRegion();<br /><br />    /* Variables */<br />    GLint mProgram;   // The shader<br />    GLint mPosAttrib; // Attribute for the surface corners in screen coordinates<br />    GLint mUvAttrib;  // Attribute for the surface corners in GL coordinates<br /><br />    GLint mDUniform;        // uD uniform location<br />    GLint mViewOrigUniform; // uViewOrig uniform location<br />    GLint mViewDimUniform;  // uViewDim uniform location<br /><br />    GLfloat mViewOrig[2];   // Current clip coordinates rectangle origin<br />    GLfloat mViewDim[2];    // Current clip coordinates rectangle dimension<br />    GLfloat mTexelDelta[2]; // Current texel delta value<br /><br />    float mRectAspectRatio;     // The rectangle aspect ratio w / h<br />    float mViewportAspectRatio; // The viewport aspect ratio w / h<br /><br />    ImageRowStorage     mZeroRowPos;     // Location of zero row (top or bottom)<br />    ImageAspectRatio    mAspectBehavior; // Keep or stretch aspect ratio.<br />};<br /><br />#endif /* RECT_SHADER_H_ */</pre>
        </blockquote>
        <p>Now let's move to <code>RectShader.cpp</code>. After adding the necessary includes:</p>
        <blockquote><pre class="prettyprint">#include "RectShader.h"<br />#include &lt;GLES2/gl2ext.h&gt;<br /><br />// NVIDIA helper include<br />#include &lt;nv_shader/nv_shader.h&gt;</pre>
        </blockquote>
        <p>Let's look at the constructor. Basically, the constructor takes the shader's file name; it then loads and compiles the program and caches the location of its attributes and uniforms. Finally, it initializes the rectangle and screen aspect ratio to default values. The aspect ratios will be recomputed every time either the screen or the image size change. We will have an object for each shader so that these initialization operations are only performed once:</p>
        <blockquote><pre class="prettyprint">RectShader::RectShader( const char *shaderName )<br />{<br />    // Load the fragment and vertex shaders.<br />    mProgram = nv_load_program( shaderName );<br /><br />    // Compile, link, and attach the shader to the program.<br />    glUseProgram( mProgram );<br /><br />    // Get pointers to the attributes in the program.<br />    mPosAttrib = glGetAttribLocation( mProgram, "aPos" );<br />    mUvAttrib  = glGetAttribLocation( mProgram, "aUV" );<br /><br />    // Set up the texture sampler to texture unit 0<br />    GLint texUni = glGetUniformLocation( mProgram, "uTex" );<br />    glUniform1i( texUni, 0 );<br /><br />    // Get the location of the uniforms we will be udpating<br />    mViewOrigUniform = glGetUniformLocation( mProgram, "uViewMin" );<br />    mViewDimUniform  = glGetUniformLocation( mProgram, "uViewDim" );<br />    mDUniform        = glGetUniformLocation( mProgram, "uD" );<br /><br />    // Initialize some default values for aspect ratio and uniforms.<br />    mViewportAspectRatio = 1.0f;<br />    mRectAspectRatio = 1.0f;<br />    mTexelDelta[0] = mTexelDelta[1] = 1.0f;<br />    mZeroRowPos = STORAGE_TOP_FIRST;<br />    mAspectBehavior = ASPECT_RATIO_KEEP;<br /><br />    updateClipRegion();<br />}</pre>
        </blockquote>
        <p><code>RectShader::bind()</code> actually activates the shader (via the call to <code>glUseProgram()</code>), sets the attributes to the arguments passed to the function and the uniforms to the values that have already been computed.</p>
        <blockquote><pre class="prettyprint">void RectShader::bind( const GLfloat vertices[8], const GLfloat uvs[8] )<br />{<br />    // Install the program object as a part of the current rendering state.<br />    glUseProgram( mProgram );<br /><br />    // Disable VBO's (vertex buffer objects) for attributes.<br />    glBindBuffer( GL_ARRAY_BUFFER, 0 );<br />    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );<br /><br />    // Set the attribute mPosAttrib with the vertices in the screen coordinates...<br />    glVertexAttribPointer( mPosAttrib, 2, GL_FLOAT, GL_FALSE, 0, vertices );<br />    // ... and enable it.<br />    glEnableVertexAttribArray( mPosAttrib );<br /><br />    // Set the attribute mUvAttrib with the vertices in the GL coordinates...<br />    glVertexAttribPointer( mUvAttrib, 2, GL_FLOAT, GL_FALSE, 0, uvs );<br />    // ... and enable it.<br />    glEnableVertexAttribArray( mUvAttrib );<br /><br />    // Update the uniforms<br />    glUniform2f( mViewOrigUniform, mViewOrig[0], mViewOrig[1] );<br />    glUniform2f( mViewDimUniform,  mViewDim[0] , mViewDim[1] );<br />    glUniform2f( mDUniform, mTexelDelta[0], mTexelDelta[1] );<br />}</pre>
        </blockquote>
        <p>The vertex buffer objects (VBO) are a caching mechanism which allows to keep the vertex data in the high-performance graphics memory and render directly from there, removing the need to resend the data every time a primitive is drawn. In this example, we are disabling VBOs since the number of vertices small.</p>
        <p>We now add functions to be called when the screen size or the image size change. These functions update the aspect ratios and call <code>updateClipRegion()</code> to compute the new values for the uniforms.</p>
        <blockquote><pre class="prettyprint">void RectShader::setViewportAspectRatio( float width, float height)<br />{<br />    // Update the viewport aspect ration<br />    mViewportAspectRatio = width / height;<br /><br />    // Update the viewport region the image will cover.<br />    updateClipRegion();<br />}<br /><br />void RectShader::setImageSize( float width, float height, ImageRowStorage zeroRowPos, ImageAspectRatio aspect )<br />{<br />    // Update the rectangle aspect ratio<br />    mRectAspectRatio = width / height;<br />    mZeroRowPos = zeroRowPos;<br />    mAspectBehavior = aspect;<br /><br />    // Update the texel delta.<br />    mTexelDelta[0] = 1.0f / width;<br />    mTexelDelta[1] = 1.0f / height;<br /><br />    // Update the viewport region the image will cover.<br />    updateClipRegion();<br />}</pre>
        </blockquote>
        <p>The <code>updateClipRegion</code> function computes the new clip coordinates area that the rectangle will take based on the choice to keep the aspect ratio of the image or stretch it to fill the entire screen. In addition, if the top row is stored first in memory (as it is usually for images), we flip the vertical axis. This is because OpenGL assumes the first byte in the image is the bottom row. See the <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml">glTexImage2D reference</a> for more details.</p>
        <blockquote><pre class="prettyprint">void RectShader::updateClipRegion()<br />{<br />    if (mAspectBehavior == ASPECT_RATIO_KEEP)<br />    {<br />      if ( mViewportAspectRatio &gt; mRectAspectRatio )<br />      {<br />	// Viewport is wider than rectangle<br />	// Use entire viewport height and clip width<br />	mViewOrig[0] = -1.0f + (mViewportAspectRatio - mRectAspectRatio) / 2.0f;<br />	mViewOrig[1] = -1.0f;<br />	mViewDim[0] =  2.0f - (mViewportAspectRatio - mRectAspectRatio);<br />	mViewDim[1] =  2.0f;<br />      }	
      else<br />      {<br />	// Viewport is taller than rectangle<br />	// Use entire viewport width and clip height<br />	mViewOrig[0] = -1.0f;<br />	mViewOrig[1] = -1.0f + (1.0f / mViewportAspectRatio - 1.0f / mRectAspectRatio) / 2.0f;<br />	mViewDim[0] =  2.0f;<br />	mViewDim[1] =  2.0f - (1.0f / mViewportAspectRatio - 1.0f / mRectAspectRatio);<br />      }<br />    }<br />    else<br />    {<br />      mViewOrig[0] = mViewOrig[1] = -1.0f;<br />      mViewDim[0] = mViewDim[1] = 2.0f;<br />    }<br /><br />    // If zero row is at the top, we need to flip the vertical signs<br />    if ( mZeroRowPos == STORAGE_TOP_FIRST )<br />    {<br />      mViewOrig[1] = -mViewOrig[1];<br />      mViewDim[1] = -mViewDim[1];<br />    }<br />}</pre>
        </blockquote>
        <p>Finally, we add two functions to return the values of the computed uniforms. We will pass these values to other shaders when we draw features on top of the image in the next section.</p>
        <blockquote><pre class="prettyprint">void RectShader::getOrigUniform(GLfloat origin[2]) const<br />{<br />    origin[0] = mViewOrig[0];<br />    origin[1] = mViewOrig[1];<br />}<br /><br />void RectShader::getDimUniform(GLfloat dim[2]) const<br />{<br />    dim[0] = mViewDim[0];<br />    dim[1] = mViewDim[1];<br />}</pre>
        </blockquote>
        <p>In the destructor, we only need to delete the program and we're done:</p>
        <blockquote><pre class="prettyprint">RectShader::~RectShader()<br />{<br />    // Delete the program object<br />    glDeleteProgram( mProgram );<br />}</pre>
        </blockquote>
        <p>Now we need one more class. Create a class called <code>DrawRect</code>, which will select the correct shader to use and will perform the actual rendering. The header file is really simple and it should only contain the following code:</p>
        <blockquote><pre class="prettyprint">#ifndef DRAW_RECT_H<br />#define DRAW_RECT_H<br /><br />#include &lt;GLES2/gl2.h&gt;<br /><br />class RectShader;<br /><br />class DrawRect<br />{<br />public:<br /><br />    DrawRect();<br /><br />    /*<br />     * Set what shader should be used to render the texture.<br />     */<br />    void setShader( RectShader *shader );<br /><br />    /*<br />     * Render the texture.<br />     */<br />    void draw( GLint tex );<br /><br />private:<br /><br />    RectShader *mShader;      // Pointer to the current shader<br />};<br /><br />#endif</pre>
        </blockquote>
        <p>The cpp file is very straight-forward too:</p>
        <blockquote><pre class="prettyprint">#include "DrawRect.h"<br />#include "RectShader.h"<br /><br />static GLushort indices[4] = { 0, 1, 2, 3 };<br /><br />static GLfloat vertices[8] = { 1.0f, 0.0f,<br />			       0.0f, 0.0f,<br />			       1.0f, 1.0f,<br />			       0.0f, 1.0f };<br /><br />static GLfloat uvs[8] =      { 1.0f, 0.0f,<br />			       0.0f, 0.0f,<br />			       1.0f, 1.0f,<br />			       0.0f, 1.0f };<br /><br />DrawRect::DrawRect()<br />{<br />    mShader = NULL;<br />}<br /><br />void DrawRect::setShader( RectShader *shader )<br />{<br />    mShader = shader;<br />}<br /><br />void DrawRect::draw( GLint tex )<br />{<br />    // Initialize the shader.<br />    mShader-&gt;bind( vertices, uvs );<br /><br />    // Select the active texture unit.<br />    glActiveTexture( GL_TEXTURE0 );<br /><br />    // Bind our texture to the texturing target.<br />    glBindTexture( GL_TEXTURE_2D, tex );<br /><br />    // Perform the actual drawing.<br />    glDrawElements( GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_SHORT, indices );<br />}</pre>
        </blockquote>
        <p>Now we need to modify the Engine class. First, in the header file, we need to add a couple of includes:</p>
        <blockquote><pre class="prettyprint">#include &lt;nv_ui/nv_ui_rect.h&gt;<br /><br />#include &lt;memory&gt;<br />#include &lt;vector&gt;<br /><br />#include "DrawRect.h"<br />#include "RectShader.h"</pre>
        </blockquote>
        <p>Then we need to change <code>updateFrame</code> to take a time step argument, and add a method that advances time:</p>
        <blockquote><pre class="prettyprint">void updateFrame( bool interactible, long deltaTime );
<br />/**<br /> * Advance the time counter by the amount of time elapsed.<br /> */<br />void advanceTime( long deltaTime )<br />{<br />    mTimeVal += deltaTime * 0.001;<br />}</pre>
        </blockquote>
        <p>Finally we need a few member variables:</p>
        <blockquote><pre class="prettyprint">// Texture and shaders<br />GLuint                      mImgTexture;<br />std::unique_ptr&lt;DrawRect&gt;   mDrawRect;<br />std::unique_ptr&lt;RectShader&gt; mRectShader[2];<br /><br />// Variables for the UI<br />NvUIRect mUiButtonZone[2];<br />void    *mClockText;<br />void    *mUiPauseText;<br />void    *mUiButton[2];<br />int      mHitButton;<br />double   mTimeVal;</pre>
        </blockquote>
        <p>But we are not going to use a couple of the old variables so you can remove the following:</p>
        <blockquote><pre class="prettyprint">void *mUiText[2];<br />int   mTouchX, mTouchY;</pre>
        </blockquote>
        <p>Now we need to change the implementation of a few functions in the cpp file, but first we need to add an include and define a couple of colors for the UI:</p>
        <blockquote><pre class="prettyprint">#include &lt;nv_glesutil/nv_images.h&gt;<br /><br />// Define packed colors<br />NvPackedColor activeColor   = NV_PACKED_COLOR( 250, 180, 50, 255 );<br />NvPackedColor deactiveColor = NV_PACKED_COLOR( 255, 255, 255, 255 );</pre>
        </blockquote>
        <p>The constructor and destructor aren't changed much, we just need to initialize a bunch of different UI components and free them:</p>
        <blockquote><pre class="prettyprint">Engine::Engine( NvEGLUtil &amp; egl, struct android_app *app )<br />    : mEgl( egl ), mApp( app ), mResizePending( false ), mActiveMode( true ),<br />    mForceRender( FRAMES_TO_RENDER ), mUiInitialized( false )   
{<br />    // Save a pointer to the engine in the Android app<br />    app-&gt;userData = this;<br /><br />    // Save pointers to the implementation of the callback functions in the<br />    // Android app<br />    app-&gt;onAppCmd     = &amp;Engine::handleCmdThunk;<br />    app-&gt;onInputEvent = &amp;Engine::handleInputThunk;<br /><br />    // Initialize the nv_shader library<br />    nv_shader_init( app-&gt;activity-&gt;assetManager );<br /><br /><span style="background-color: #ffffe0;">    // Initialize all the UI components</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mClockText   = NULL;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mUiPauseText = NULL;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mUiButton[0] = NULL;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mUiButton[1] = NULL;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mHitButton   = 0;</span><br /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Initialize the mDrawRect and mRectShader objects</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mDrawRect      = NULL;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mRectShader[0] = NULL;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mRectShader[1] = NULL;</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Initialize the texture</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mImgTexture    = 0;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Initialize the time counter</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mTimeVal       = 0.0;</span><br />}<br /><br />Engine::~Engine()<br />{<br />    // Free the allocated BitFonts<br /><span style="background-color: #ffffe0;">    NVBFTextFree( mUiButton[0] );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextFree( mUiButton[1] );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextFree( mUiPauseText );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextFree( mClockText );</span><br />    NVBFCleanup();<br /><br /><span style="background-color: #ffffe0;">    // Delete the texture</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    glDeleteTextures( 1, &amp;mImgTexture );</span><br />}</pre>
        </blockquote>
        <p>The method <code>Engine::handleInput()</code> needs to be changed to account for the fact that, instead of tracking the touch positions, we now need to detect and save which button has been pressed by the user:</p>
        <blockquote><pre class="prettyprint">int Engine::handleInput( AInputEvent *event )<br />{<br />    //We only handle motion events (touchscreen) and key (button/key) events<br />    int32_t eventType = AInputEvent_getType( event );<br /><br />    if( eventType == AINPUT_EVENT_TYPE_MOTION )<br />    {<br />	int32_t action = AMOTION_EVENT_ACTION_MASK &amp; AMotionEvent_getAction( ( const AInputEvent * )event );<br /><br /><span style="background-color: #ffffe0;">	int32_t mx = AMotionEvent_getX( event, 0 );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	int32_t my = AMotionEvent_getY( event, 0 );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	if( isActiveMode() )</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	{</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    // Check if the touch was inside of the first button...</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    if( mUiButtonZone[0].inside( mx, my ) )      { mHitButton = 0; }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    // ... or the second</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    else if( mUiButtonZone[1].inside( mx, my ) ) { mHitButton = 1; }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	}</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	else</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	{</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    // A tap on the screen takes us out of autopause into active mode if</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    // we were paused.  No other touch processing is done.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    if( action == AMOTION_EVENT_ACTION_DOWN )</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    {</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">		setActiveMode( true );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">		return 0;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	}</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	return 1;</span><br />    }<br />    else if( eventType == AINPUT_EVENT_TYPE_KEY )<br />    {<br />	int32_t code = AKeyEvent_getKeyCode( ( const AInputEvent * ) event );<br /><br />	// if we are in active mode, we eat the back button and move into<br />	// pause mode.  If we are already in pause mode, we allow the back<br />	// button to be handled by the OS, which means we'll be shut down<br />	if( ( code == AKEYCODE_BACK ) &amp;&amp; mActiveMode )<br />	{<br />	    setActiveMode( false );<br />	    return 1;<br />	}<br />    }<br />    return 0;<br />}</pre>
        </blockquote>
        <p>In <code>Engine::updateFrame()</code> we only need to add a couple of lines of code to advance the clock:</p>
        <blockquote><pre class="prettyprint">void Engine::updateFrame( bool interactible, long deltaTime )<br />{<br />    if( interactible )<br />    {<br />	// Each frame, we check to see if the window has resized.  While the<br />	// various events we get _should_ cover this, in practice, it appears<br />	// that the safest move across all platforms and OSes is to check at<br />	// the top of each frame<br />	checkWindowResized();<br /><br />	// Time stands still when we're auto-paused, and we don't<br />	// automatically render<br />	if( mActiveMode )<br />	{<br /><span style="background-color: #ffffe0;">	    // The time needs to advance in active mode.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	    advanceTime( deltaTime );</span><br /><br />	    // This will try to set up EGL if it isn't set up<br />	    // When we first set up EGL completely, we also load our GLES resources<br />	    // If these are already set up or we succeed at setting them all up now, then<br />	    // we go ahead and render.<br />	    renderFrame( true );<br />	}<br />	else if( isForcedRenderPending() )  // forced rendering when needed for UI, etc.<br />	{<br />	    // This forces to render.<br />	    renderFrame( true );<br />	}<br />    }<br />    else<br />    {<br />	// Even if we are not interactible, we may be visible, so we<br />	// HAVE to do any forced renderings if we can.  We must also<br />	// check for resize, since that may have been the point of the<br />	// forced render request in the first place!<br />	if( isForcedRenderPending() &amp;&amp; mEgl.isReadyToRender( false ) )<br />	{<br />	     checkWindowResized();<br />	     renderFrame( false );<br />	}<br />    }<br />}</pre>
        </blockquote>
        <p><code>Engine::renderFrame()</code> is very similar to the previous example as well, but we need to select the shader based on the button that was pressed, and render the button (change colors depeding on selection) and the clock:</p>
        <blockquote><pre class="prettyprint">bool Engine::renderFrame( bool allocateIfNeeded )<br />{<br />    // Check that EGL is ready to render. If allocateIfNeeded<br />    // try to also allocate the rendering surface and bind it<br />    // to the context.<br />    if( !mEgl.isReadyToRender( allocateIfNeeded ) )<br />    {<br /> 	return false;<br />    }<br /><br />    // Make sure that the UI is initialized<br />    if( !initUI() )<br />    {<br />	LOGW( "Could not initialize UI - assets may be missing!" );<br />	ANativeActivity_finish( mApp-&gt;activity );<br />	return false;<br />    }<br />    resizeIfNeeded();<br /><br />    // Set up viewport<br />    glViewport( ( GLint )0, ( GLint )0,<br />		( GLsizei )( mEgl.getWidth() ), ( GLsizei )( mEgl.getHeight() ) );<br /><br /><span style="background-color: #ffffe0;">    // Clear buffers as necessary</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    /* Do some rendering here */</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Based on the button that is selected choose the shader that should be used...</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mDrawRect-&gt;setShader( mRectShader[mHitButton].get() );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // ... and pass the texture to the shader.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mDrawRect-&gt;draw( mImgTexture );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Render the rendering bitfont text overlaid here.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextRenderPrep();</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Update the clock.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    if( mClockText )</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    {</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	// Set the correct color depending on the mActiveMode</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextSetMultiplyColor( mClockText,</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	mActiveMode ? activeColor : deactiveColor );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextRender( mClockText );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	// We update the clock text &gt;after&lt; rendering, so it will change on pause.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	int mins = mTimeVal / 60;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	float secs = ( float )mTimeVal - mins * 60;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	char str[32];</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	sprintf( str, "%03d:%05.2f", mins, secs );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextSetString( mClockText, str );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    }</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Render the buttons.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    if( !mActiveMode )</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    {</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextRender( mUiPauseText );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    else</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    {</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextSetMultiplyColor( mUiButton[mHitButton], activeColor );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextSetMultiplyColor( mUiButton[( mHitButton + 1 ) % 2], deactiveColor );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextRender( mUiButton[0] );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">	NVBFTextRender( mUiButton[1] );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    }</span><br /><br />    // Done rendering overlaid text.<br />    NVBFTextRenderDone();<br /><br />    if( mForceRender &gt; 0 ) { mForceRender--; }<br /><br />    // Swap the buffers, which indicates we're done with rendering this frame<br />    mEgl.swap();<br /><br />    return true;<br />}</pre>
        </blockquote>
        <p>In the methods <code>Engine::initUI()</code> and <code>Engine::resizeIfNeeded()</code>, we just need to allocate or update different UI components or objects:</p>
        <blockquote><pre class="prettyprint">bool Engine::initUI()<br />{<br />    // The UI might have been initialized already<br />    if( mUiInitialized ) { return true; }<br /><br />   LOGD( "Initializing UI" );<br /><br />    // Initialize the NVIDIA bitfonts<br />    const int NUM_FONTS = 2;<br />    static NvBool fontsSplit[NUM_FONTS] = {1, 1}; // all are split<br />    static const char * fontFiles[NUM_FONTS] = { "courier+lucida_256.dds", "utahcond+bold_1024.dds" };<br />    if( NVBFInitialize( NUM_FONTS, ( const char ** )fontFiles, fontsSplit, 0 ) )<br />    {<br />	LOGW( "Could not initialize NvBitFont" );<br />	return false;<br />    }<br /><br /><span style="background-color: #ffffe0;">    // Allocate the text for the clock and set its properties</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mClockText = NVBFTextAlloc();</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetFont( mClockText, 1 ); // should look up by font file name.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetSize( mClockText, 32 );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetColor( mClockText, NV_PC_PREDEF_WHITE );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetString( mClockText, "000:00.00" );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Allocate the text for the text of the autopause mode and set its properties</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mUiPauseText = NVBFTextAlloc();</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetFont( mUiPauseText, 2 ); // should look up by font file name.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetSize( mUiPauseText, 32 );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetColor( mUiPauseText, NV_PC_PREDEF_WHITE );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetString( mUiPauseText,</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    			NVBF_COLORSTR_RED NVBF_STYLESTR_BOLD "Auto-pause:\n" NVBF_STYLESTR_NORMAL</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">   			NVBF_COLORSTR_BLUE "Press back to quit\nTap window to resume" );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // UI Buttons</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mUiButton[0] = NVBFTextAlloc();</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetFont( mUiButton[0], 2 ); // should look up by font file name.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetSize( mUiButton[0], 48 );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetColor( mUiButton[0], NV_PC_PREDEF_WHITE );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetShadow( mUiButton[0], 5, NV_PC_PREDEF_BLACK );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetString( mUiButton[0], NVBF_STYLESTR_BOLD "ON" );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mUiButton[1] = NVBFTextAlloc();</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetFont( mUiButton[1], 2 ); // should look up by font file name.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetSize( mUiButton[1], 48 );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetColor( mUiButton[1], NV_PC_PREDEF_WHITE );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetShadow( mUiButton[1], 5, NV_PC_PREDEF_BLACK );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetString( mUiButton[1], NVBF_STYLESTR_BOLD "OFF" );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Set the correct button as active.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mHitButton = 1;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    NVBFTextSetMultiplyColor( mUiButton[mHitButton], activeColor );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Load the texture image</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mImgTexture = NvCreateTextureFromDDSEx( "nvidia_green.dds", false, false, NULL, NULL, NULL, NULL );</span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Allocate the objects</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mDrawRect.reset( new DrawRect );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mRectShader[0].reset( new RectShader( "filter" ) );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mRectShader[0]-&gt;setImageSize( 1366.0, 720.0,</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    		RectShader::STORAGE_TOP_FIRST, RectShader::ASPECT_RATIO_STRETCH );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mRectShader[1].reset( new RectShader( "plain" ) );</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    mRectShader[1]-&gt;setImageSize( 1366.0, 720.0,</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">   		RectShader::STORAGE_TOP_FIRST, RectShader::ASPECT_RATIO_STRETCH );</span><br /><br />    mUiInitialized = true;<br /><br />    return true;<br />}</pre>
        </blockquote>
        <blockquote><pre class="prettyprint">bool Engine::resizeIfNeeded()<br />{<br />    // Do we need to resize?<br />    if( !mResizePending ) { return false; }<br /><br />    // Get the target height and width<br />    int w = mEgl.getWidth();<br />    int h = mEgl.getHeight();<br />    int textHeight = ( w &gt; h ) ? ( h / 16 ) : ( w / 16 );<br /><br />    // Change the resolution to the correct width and height<br />    NVBFSetScreenRes( w, h );<br /><br />    // Also update the size of the characters and their location<br />    if( mClockText )<br />    {<br />	NVBFTextSetSize( mClockText, textHeight );<br />	NVBFTextCursorAlign( mClockText, NVBF_ALIGN_LEFT, NVBF_ALIGN_TOP );<br />	NVBFTextCursorPos( mClockText, 10, 10 );<br />    }<br />    if( mUiPauseText )<br />    {<br />	NVBFTextSetSize( mUiPauseText, textHeight );<br />	NVBFTextCursorAlign( mUiPauseText, NVBF_ALIGN_CENTER, NVBF_ALIGN_BOTTOM );<br />	NVBFTextCursorPos( mUiPauseText, w / 2, h / 2 );<br />    }<br />    if( mUiButton[0] )<br />    {<br />	NVBFTextSetSize( mUiButton[0], textHeight );<br />	NVBFTextCursorAlign( mUiButton[0], NVBF_ALIGN_RIGHT, NVBF_ALIGN_BOTTOM );<br />	NVBFTextCursorPos( mUiButton[0], w - textHeight * 4, h - 10 );<br />	mUiButtonZone[0].set( w - textHeight * 6, h - 10 - textHeight, textHeight * 2, textHeight );<br />    }<br />    if( mUiButton[1] )<br />    {<br />	NVBFTextSetSize( mUiButton[1], textHeight );<br />	NVBFTextCursorAlign( mUiButton[1], NVBF_ALIGN_RIGHT, NVBF_ALIGN_BOTTOM );<br />	NVBFTextCursorPos( mUiButton[1], w - textHeight, h - 10 );<br />	mUiButtonZone[1].set( w - textHeight * 3, h - 10 - textHeight, textHeight * 2, textHeight );<br />    }<br />    if( mRectShader[0].get() != nullptr )<br />    {<br />	mRectShader[0]-&gt;setViewportAspectRatio( ( float ) w, float( h ) );<br />    }<br />    if( mRectShader[1].get() != nullptr )<br />    {<br />	mRectShader[1]-&gt;setViewportAspectRatio( ( float ) w, float( h ) );<br />    }<br /><br />    mResizePending = false;<br /><br />    return true;<br />}</pre>
        </blockquote>
        <p>We need also to update our call to <code>updateFrame</code> in <code>SimpleNativeGL_NV.cpp</code> to pass the time delta since the last call to <code>updateFrame</code>. Open <code>SimpleNativeGL_NV.cpp</code> and add the following lines in the <code>android_main</code> function:</p>
        <blockquote><pre class="prettyprint">std::unique_ptr&lt;Engine&gt; engine( new Engine( *egl, app ) );<br /><br /><span style="background-color: #ffffe0;">long lastTime = egl-&gt;getSystemTime();</span><br /><br />// loop waiting for stuff to do.<br /><br />while( nv_app_status_running( app ) )<br />{<br />    // Read all pending events.<br />    int ident;<br />    int events;<br />    struct android_poll_source *source;<br /><br />    // If not rendering, we will block forever waiting for events.<br />    // If animating, we loop until all events are read, then continue<br />    // to draw the next frame of animation.<br />    while( ( ident = ALooper_pollAll( ( ( nv_app_status_focused( app ) &amp;&amp; engine-&gt;isActiveMode() ) ? 1 : 250 ),<br />    					NULL, &amp;events, ( void ** ) &amp;source ) ) &gt;= 0 )<br />    {<br />	// If we timed out, then there are no pending messages.<br />	if( ident == ALOOPER_POLL_TIMEOUT ) { break; }<br /><br />	// Process this event.<br />	if( source != NULL )                { source-&gt;process( app, source ); }<br /><br />	// Check if we are exiting.  If so, dump out.<br />	if( !nv_app_status_running( app ) ) { break; }<br />    }<br /><br /><span style="background-color: #ffffe0;">    long currentTime = egl-&gt;getSystemTime();</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Clamp time - it must not go backwards, and we don't</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // want it to be more than a half second to avoid huge</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // delays causing issues.  Note that we do not clamp to above</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // zero because some tools will give us zero delta.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    long deltaTime = currentTime - lastTime;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    if     ( deltaTime &lt; 0 )    { deltaTime = 0; }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    else if( deltaTime &gt; 500 )  { deltaTime = 500; }</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    lastTime = currentTime;</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // Update the frame, which optionally updates time and animations,</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    // and renders.</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;">    engine-&gt;updateFrame( nv_app_status_interactable( app ), deltaTime );</span><br />}</pre>
        </blockquote>
        <p>And now you're finally ready to test your application! Right-click on the project folder, <b>Run as &gt; Android Application</b>.</p>
        <p>If you followed the instructions in this tutorial, the application should start on your device and you should see the NVIDIA wallpaper. However, when you press the <b>ON</b> button you will just see a black screen on your device, instead of the gradient image.</p>
        <p>Let's try to find out why. Open the Logcat (<b>Window &gt; Show View &gt; Other &gt; Android &gt; LogCat</b>); if  you filter the messages by with the tag <code>nv_shader</code> you should see something like this:</p>
        <p><a class="MCPopupThumbnailLink" href="images/gl_shadererror.png"><img class="MCPopupThumbnail img" data-mc-width="1275" data-mc-height="864" src="images/gl_shadererror_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-width: 700px;mc-thumbnail-max-height: auto;" tabindex="" /></a>
        </p>
        <p>If you look at the line above the selected one, you will notice that <code>filter.vert</code> was correctly compiled while <code>filter.frag</code> generated an error. We also know the lines of the errors, the numbers in parenthesis. Line 59 of the shader is (your line numbering might be different):</p>
        <blockquote><pre class="prettyprint">gl_FragColor += 2 * texture2D( uTex, vTexCoord + vec2(   0.0, -uD.y ) );<br />...<br />gl_FragColor -= 2 * texture2D( uTex, vTexCoord + vec2(   0.0,  uD.y ) );</pre>
        </blockquote>
        <p>and the error says::</p>
        <blockquote><pre class="prettyprint">error C7011 Implicit cast from "int" to "mediump float"</pre>
        </blockquote>
        <p>Basically, the problem is that we cannot do implicit casting in GL and everything is assumed to be float; we can fix the problem by replacing the above lines with:</p>
        <blockquote><pre class="prettyprint">gl_FragColor += 2.0 * texture2D( uTex, vTexCoord + vec2(   0.0, -uD.y ) );<br />...<br />gl_FragColor -= 2.0 * texture2D( uTex, vTexCoord + vec2(   0.0,  uD.y ) );</pre>
        </blockquote>
        <p>In general, when you get a black screen instead of what you were expecting, the first thing you should do is go look at the LogCat and check for errors. Much like in the implicit cast example shown above, if you are using the utility functions from NVIDIA, errors shoud be caught and logged in the LogCat.</p>
        <p>&#160;</p>
        <p>This concludes our GL tutorial.</p>
        <p>&#160;</p>
        <p>&#160;</p>
        <div id="pagefooter">
            <br />
        </div>
        <hr style="height: 1px;" width="100%" size="0" align="center" />
        <script type="text/javascript" src="../../resources/stylesheets/run_prettify.js?lang=vb" autoload="true">
        </script>
        <p>&#160;</p>
        <div class="buttons inline-buttons clearfix topicToolbarProxy topicToolbarProxystyle.css" style="mc-topic-toolbar-items: ;">
            <div class="button-group-container-left">
                <button class="button needs-pie previous-topic-button" type="button" title="Navigate previous">
                    <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="previous topic" />
                </button>
                <div class="button current-topic-index-button disabled"><span class="sequence-index"></span> of <span class="sequence-total"></span></div>
                <button class="button needs-pie next-topic-button" type="button" title="Navigate next">
                    <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="next topic" />
                </button>
            </div>
        </div>
        <p> </p>
        <p><span style="color: #696969; font-size: 8pt;">NVIDIA&#160;AndroidWorks Documentation Rev. 1.2.150805 ©2015. NVIDIA Corporation. All Rights Reserved.</span>
        </p>
    </body>
</html>